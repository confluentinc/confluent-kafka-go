<!DOCTYPE html>
<html>
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <meta content="#375EAB" name="theme-color"/>
  <title>
   kafka - The Go Programming Language
  </title>
  <link href="//golang.org/lib/godoc/style.css" rel="stylesheet" type="text/css"/>
  <link href="//golang.org/lib/godoc/jquery.treeview.css" rel="stylesheet"/>
  <script>
   window.initFuncs = [];
  </script>
  <script defer="" src="//golang.org/lib/godoc/jquery.js">
  </script>
  <script defer="" src="//golang.org/lib/godoc/jquery.treeview.js">
  </script>
  <script defer="" src="//golang.org/lib/godoc/jquery.treeview.edit.js">
  </script>
  <script>
   var goVersion = "go1.11.4";
  </script>
  <script defer="" src="//golang.org/lib/godoc/godocs.js">
  </script>
 </head>
 <body>
  <div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
   ...
  </div>
  <!-- #lowframe -->
  <div class="wide" id="page">
   <div class="container">
    <h1>
     Package kafka
     <span class="text-muted">
     </span>
    </h1>
    <div id="nav">
    </div>
    <!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
    <!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
    <script type="text/javascript">
     document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
    </script>
    <div id="short-nav">
     <dl>
      <dd>
       <code>
        import "github.com/confluentinc/confluent-kafka-go/kafka"
       </code>
      </dd>
     </dl>
     <dl>
      <dd>
       <a class="overviewLink" href="#pkg-overview">
        Overview
       </a>
      </dd>
      <dd>
       <a class="indexLink" href="#pkg-index">
        Index
       </a>
      </dd>
      <dd>
      </dd>
     </dl>
    </div>
    <!-- The package's Name is printed as title by the top-level template -->
    <div class="toggleVisible" id="pkg-overview">
     <div class="collapsed">
      <h2 class="toggleButton" title="Click to show Overview section">
       Overview ▹
      </h2>
     </div>
     <div class="expanded">
      <h2 class="toggleButton" title="Click to hide Overview section">
       Overview ▾
      </h2>
      <p>
       Package kafka provides high-level Apache Kafka producer and consumers
using bindings on-top of the librdkafka C library.
      </p>
      <h3 id="hdr-High_level_Consumer">
       High-level Consumer
      </h3>
      <p>
       * Decide if you want to read messages and events from the `.Events()` channel
(set `"go.events.channel.enable": true`) or by calling `.Poll()`.
      </p>
      <p>
       * Create a Consumer with `kafka.NewConsumer()` providing at
least the `bootstrap.servers` and `group.id` configuration properties.
      </p>
      <p>
       * Call `.Subscribe()` or (`.SubscribeTopics()` to subscribe to multiple topics)
to join the group with the specified subscription set.
Subscriptions are atomic, calling `.Subscribe*()` again will leave
the group and rejoin with the new set of topics.
      </p>
      <p>
       * Start reading events and messages from either the `.Events` channel
or by calling `.Poll()`.
      </p>
      <p>
       * When the group has rebalanced each client member is assigned a
(sub-)set of topic+partitions.
By default the consumer will start fetching messages for its assigned
partitions at this point, but your application may enable rebalance
events to get an insight into what the assigned partitions where
as well as set the initial offsets. To do this you need to pass
`"go.application.rebalance.enable": true` to the `NewConsumer()` call
mentioned above. You will (eventually) see a `kafka.AssignedPartitions` event
with the assigned partition set. You can optionally modify the initial
offsets (they'll default to stored offsets and if there are no previously stored
offsets it will fall back to `"auto.offset.reset"`
which defaults to the `latest` message) and then call `.Assign(partitions)`
to start consuming. If you don't need to modify the initial offsets you will
not need to call `.Assign()`, the client will do so automatically for you if
you dont.
      </p>
      <p>
       * As messages are fetched they will be made available on either the
`.Events` channel or by calling `.Poll()`, look for event type `*kafka.Message`.
      </p>
      <p>
       * Handle messages, events and errors to your liking.
      </p>
      <p>
       * When you are done consuming call `.Close()` to commit final offsets
and leave the consumer group.
      </p>
      <h3 id="hdr-Producer">
       Producer
      </h3>
      <p>
       * Create a Producer with `kafka.NewProducer()` providing at least
the `bootstrap.servers` configuration properties.
      </p>
      <p>
       * Messages may now be produced either by sending a `*kafka.Message`
on the `.ProduceChannel` or by calling `.Produce()`.
      </p>
      <p>
       * Producing is an asynchronous operation so the client notifies the application
of per-message produce success or failure through something called delivery reports.
Delivery reports are by default emitted on the `.Events()` channel as `*kafka.Message`
and you should check `msg.TopicPartition.Error` for `nil` to find out if the message
was succesfully delivered or not.
It is also possible to direct delivery reports to alternate channels
by providing a non-nil `chan Event` channel to `.Produce()`.
If no delivery reports are wanted they can be completely disabled by
setting configuration property `"go.delivery.reports": false`.
      </p>
      <p>
       * When you are done producing messages you will need to make sure all messages
are indeed delivered to the broker (or failed), remember that this is
an asynchronous client so some of your messages may be lingering in internal
channels or tranmission queues.
To do this you can either keep track of the messages you've produced
and wait for their corresponding delivery reports, or call the convenience
function `.Flush()` that will block until all message deliveries are done
or the provided timeout elapses.
      </p>
      <p>
       * Finally call `.Close()` to decommission the producer.
      </p>
      <h3 id="hdr-Events">
       Events
      </h3>
      <p>
       Apart from emitting messages and delivery reports the client also communicates
with the application through a number of different event types.
An application may choose to handle or ignore these events.
      </p>
      <h3 id="hdr-Consumer_events">
       Consumer events
      </h3>
      <p>
       * `*kafka.Message` - a fetched message.
      </p>
      <p>
       * `AssignedPartitions` - The assigned partition set for this client following a rebalance.
Requires `go.application.rebalance.enable`
      </p>
      <p>
       * `RevokedPartitions` - The counter part to `AssignedPartitions` following a rebalance.
`AssignedPartitions` and `RevokedPartitions` are symmetrical.
Requires `go.application.rebalance.enable`
      </p>
      <p>
       * `PartitionEOF` - Consumer has reached the end of a partition.
NOTE: The consumer will keep trying to fetch new messages for the partition.
      </p>
      <p>
       * `OffsetsCommitted` - Offset commit results (when `enable.auto.commit` is enabled).
      </p>
      <h3 id="hdr-Producer_events">
       Producer events
      </h3>
      <p>
       * `*kafka.Message` - delivery report for produced message.
Check `.TopicPartition.Error` for delivery result.
      </p>
      <h3 id="hdr-Generic_events_for_both_Consumer_and_Producer">
       Generic events for both Consumer and Producer
      </h3>
      <p>
       * `KafkaError` - client (error codes are prefixed with _) or broker error.
These errors are normally just informational since the
client will try its best to automatically recover (eventually).
      </p>
      <p>
       * `OAuthBearerTokenRefresh` - retrieval of a new SASL/OAUTHBEARER token is required.
This event only occurs with sasl.mechanism=OAUTHBEARER.
Be sure to invoke SetOAuthBearerToken() on the Producer/Consumer/AdminClient
instance when a successful token retrieval is completed, otherwise be sure to
invoke SetOAuthBearerTokenFailure() to indicate that retrieval failed (or
if setting the token failed, which could happen if an extension doesn't meet
the required regular expression); invoking SetOAuthBearerTokenFailure() will
schedule a new event for 10 seconds later so another retrieval can be attempted.
      </p>
      <p>
       Hint: If your application registers a signal notification
(signal.Notify) makes sure the signals channel is buffered to avoid
possible complications with blocking Poll() calls.
      </p>
      <p>
       Note: The Confluent Kafka Go client is safe for concurrent use.
      </p>
     </div>
    </div>
    <div class="toggleVisible" id="pkg-index">
     <div class="collapsed">
      <h2 class="toggleButton" title="Click to show Index section">
       Index ▹
      </h2>
     </div>
     <div class="expanded">
      <h2 class="toggleButton" title="Click to hide Index section">
       Index ▾
      </h2>
      <!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
      <div id="manual-nav">
       <dl>
        <dd>
         <a href="#pkg-constants">
          Constants
         </a>
        </dd>
        <dd>
         <a href="#LibraryVersion">
          func LibraryVersion() (int, string)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient">
          type AdminClient
         </a>
        </dd>
        <dd>
         <a href="#NewAdminClient">
          func NewAdminClient(conf *ConfigMap) (*AdminClient, error)
         </a>
        </dd>
        <dd>
         <a href="#NewAdminClientFromConsumer">
          func NewAdminClientFromConsumer(c *Consumer) (a *AdminClient, err error)
         </a>
        </dd>
        <dd>
         <a href="#NewAdminClientFromProducer">
          func NewAdminClientFromProducer(p *Producer) (a *AdminClient, err error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.AlterConfigs">
          func (a *AdminClient) AlterConfigs(ctx context.Context, resources []ConfigResource, options ...AlterConfigsAdminOption) (result []ConfigResourceResult, err error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.Close">
          func (a *AdminClient) Close()
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.CreatePartitions">
          func (a *AdminClient) CreatePartitions(ctx context.Context, partitions []PartitionsSpecification, options ...CreatePartitionsAdminOption) (result []TopicResult, err error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.CreateTopics">
          func (a *AdminClient) CreateTopics(ctx context.Context, topics []TopicSpecification, options ...CreateTopicsAdminOption) (result []TopicResult, err error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.DeleteTopics">
          func (a *AdminClient) DeleteTopics(ctx context.Context, topics []string, options ...DeleteTopicsAdminOption) (result []TopicResult, err error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.DescribeConfigs">
          func (a *AdminClient) DescribeConfigs(ctx context.Context, resources []ConfigResource, options ...DescribeConfigsAdminOption) (result []ConfigResourceResult, err error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.GetMetadata">
          func (a *AdminClient) GetMetadata(topic *string, allTopics bool, timeoutMs int) (*Metadata, error)
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.SetOAuthBearerToken">
          func (a *AdminClient) SetOAuthBearerToken(oauthBearerToken OAuthBearerToken) error
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.SetOAuthBearerTokenFailure">
          func (a *AdminClient) SetOAuthBearerTokenFailure(errstr string) error
         </a>
        </dd>
        <dd>
         <a href="#AdminClient.String">
          func (a *AdminClient) String() string
         </a>
        </dd>
        <dd>
         <a href="#AdminOption">
          type AdminOption
         </a>
        </dd>
        <dd>
         <a href="#AdminOptionOperationTimeout">
          type AdminOptionOperationTimeout
         </a>
        </dd>
        <dd>
         <a href="#SetAdminOperationTimeout">
          func SetAdminOperationTimeout(t time.Duration) (ao AdminOptionOperationTimeout)
         </a>
        </dd>
        <dd>
         <a href="#AdminOptionRequestTimeout">
          type AdminOptionRequestTimeout
         </a>
        </dd>
        <dd>
         <a href="#SetAdminRequestTimeout">
          func SetAdminRequestTimeout(t time.Duration) (ao AdminOptionRequestTimeout)
         </a>
        </dd>
        <dd>
         <a href="#AdminOptionValidateOnly">
          type AdminOptionValidateOnly
         </a>
        </dd>
        <dd>
         <a href="#SetAdminValidateOnly">
          func SetAdminValidateOnly(validateOnly bool) (ao AdminOptionValidateOnly)
         </a>
        </dd>
        <dd>
         <a href="#AlterConfigsAdminOption">
          type AlterConfigsAdminOption
         </a>
        </dd>
        <dd>
         <a href="#AlterOperation">
          type AlterOperation
         </a>
        </dd>
        <dd>
         <a href="#AlterOperation.String">
          func (o AlterOperation) String() string
         </a>
        </dd>
        <dd>
         <a href="#AssignedPartitions">
          type AssignedPartitions
         </a>
        </dd>
        <dd>
         <a href="#AssignedPartitions.String">
          func (e AssignedPartitions) String() string
         </a>
        </dd>
        <dd>
         <a href="#BrokerMetadata">
          type BrokerMetadata
         </a>
        </dd>
        <dd>
         <a href="#ConfigEntry">
          type ConfigEntry
         </a>
        </dd>
        <dd>
         <a href="#StringMapToConfigEntries">
          func StringMapToConfigEntries(stringMap map[string]string, operation AlterOperation) []ConfigEntry
         </a>
        </dd>
        <dd>
         <a href="#ConfigEntry.String">
          func (c ConfigEntry) String() string
         </a>
        </dd>
        <dd>
         <a href="#ConfigEntryResult">
          type ConfigEntryResult
         </a>
        </dd>
        <dd>
         <a href="#ConfigEntryResult.String">
          func (c ConfigEntryResult) String() string
         </a>
        </dd>
        <dd>
         <a href="#ConfigMap">
          type ConfigMap
         </a>
        </dd>
        <dd>
         <a href="#ConfigMap.Get">
          func (m ConfigMap) Get(key string, defval ConfigValue) (ConfigValue, error)
         </a>
        </dd>
        <dd>
         <a href="#ConfigMap.Set">
          func (m ConfigMap) Set(kv string) error
         </a>
        </dd>
        <dd>
         <a href="#ConfigMap.SetKey">
          func (m ConfigMap) SetKey(key string, value ConfigValue) error
         </a>
        </dd>
        <dd>
         <a href="#ConfigResource">
          type ConfigResource
         </a>
        </dd>
        <dd>
         <a href="#ConfigResource.String">
          func (c ConfigResource) String() string
         </a>
        </dd>
        <dd>
         <a href="#ConfigResourceResult">
          type ConfigResourceResult
         </a>
        </dd>
        <dd>
         <a href="#ConfigResourceResult.String">
          func (c ConfigResourceResult) String() string
         </a>
        </dd>
        <dd>
         <a href="#ConfigSource">
          type ConfigSource
         </a>
        </dd>
        <dd>
         <a href="#ConfigSource.String">
          func (t ConfigSource) String() string
         </a>
        </dd>
        <dd>
         <a href="#ConfigValue">
          type ConfigValue
         </a>
        </dd>
        <dd>
         <a href="#Consumer">
          type Consumer
         </a>
        </dd>
        <dd>
         <a href="#NewConsumer">
          func NewConsumer(conf *ConfigMap) (*Consumer, error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Assign">
          func (c *Consumer) Assign(partitions []TopicPartition) (err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Assignment">
          func (c *Consumer) Assignment() (partitions []TopicPartition, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Close">
          func (c *Consumer) Close() (err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Commit">
          func (c *Consumer) Commit() ([]TopicPartition, error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.CommitMessage">
          func (c *Consumer) CommitMessage(m *Message) ([]TopicPartition, error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.CommitOffsets">
          func (c *Consumer) CommitOffsets(offsets []TopicPartition) ([]TopicPartition, error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Committed">
          func (c *Consumer) Committed(partitions []TopicPartition, timeoutMs int) (offsets []TopicPartition, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Events">
          func (c *Consumer) Events() chan Event
         </a>
        </dd>
        <dd>
         <a href="#Consumer.GetMetadata">
          func (c *Consumer) GetMetadata(topic *string, allTopics bool, timeoutMs int) (*Metadata, error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.GetWatermarkOffsets">
          func (c *Consumer) GetWatermarkOffsets(topic string, partition int32) (low, high int64, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.OffsetsForTimes">
          func (c *Consumer) OffsetsForTimes(times []TopicPartition, timeoutMs int) (offsets []TopicPartition, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Pause">
          func (c *Consumer) Pause(partitions []TopicPartition) (err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Poll">
          func (c *Consumer) Poll(timeoutMs int) (event Event)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.QueryWatermarkOffsets">
          func (c *Consumer) QueryWatermarkOffsets(topic string, partition int32, timeoutMs int) (low, high int64, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.ReadMessage">
          func (c *Consumer) ReadMessage(timeout time.Duration) (*Message, error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Resume">
          func (c *Consumer) Resume(partitions []TopicPartition) (err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Seek">
          func (c *Consumer) Seek(partition TopicPartition, timeoutMs int) error
         </a>
        </dd>
        <dd>
         <a href="#Consumer.SetOAuthBearerToken">
          func (c *Consumer) SetOAuthBearerToken(oauthBearerToken OAuthBearerToken) error
         </a>
        </dd>
        <dd>
         <a href="#Consumer.SetOAuthBearerTokenFailure">
          func (c *Consumer) SetOAuthBearerTokenFailure(errstr string) error
         </a>
        </dd>
        <dd>
         <a href="#Consumer.StoreOffsets">
          func (c *Consumer) StoreOffsets(offsets []TopicPartition) (storedOffsets []TopicPartition, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.String">
          func (c *Consumer) String() string
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Subscribe">
          func (c *Consumer) Subscribe(topic string, rebalanceCb RebalanceCb) error
         </a>
        </dd>
        <dd>
         <a href="#Consumer.SubscribeTopics">
          func (c *Consumer) SubscribeTopics(topics []string, rebalanceCb RebalanceCb) (err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Subscription">
          func (c *Consumer) Subscription() (topics []string, err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Unassign">
          func (c *Consumer) Unassign() (err error)
         </a>
        </dd>
        <dd>
         <a href="#Consumer.Unsubscribe">
          func (c *Consumer) Unsubscribe() (err error)
         </a>
        </dd>
        <dd>
         <a href="#CreatePartitionsAdminOption">
          type CreatePartitionsAdminOption
         </a>
        </dd>
        <dd>
         <a href="#CreateTopicsAdminOption">
          type CreateTopicsAdminOption
         </a>
        </dd>
        <dd>
         <a href="#DeleteTopicsAdminOption">
          type DeleteTopicsAdminOption
         </a>
        </dd>
        <dd>
         <a href="#DescribeConfigsAdminOption">
          type DescribeConfigsAdminOption
         </a>
        </dd>
        <dd>
         <a href="#Error">
          type Error
         </a>
        </dd>
        <dd>
         <a href="#NewError">
          func NewError(code ErrorCode, str string, fatal bool) (err Error)
         </a>
        </dd>
        <dd>
         <a href="#Error.Code">
          func (e Error) Code() ErrorCode
         </a>
        </dd>
        <dd>
         <a href="#Error.Error">
          func (e Error) Error() string
         </a>
        </dd>
        <dd>
         <a href="#Error.IsFatal">
          func (e Error) IsFatal() bool
         </a>
        </dd>
        <dd>
         <a href="#Error.String">
          func (e Error) String() string
         </a>
        </dd>
        <dd>
         <a href="#ErrorCode">
          type ErrorCode
         </a>
        </dd>
        <dd>
         <a href="#ErrorCode.String">
          func (c ErrorCode) String() string
         </a>
        </dd>
        <dd>
         <a href="#Event">
          type Event
         </a>
        </dd>
        <dd>
         <a href="#Handle">
          type Handle
         </a>
        </dd>
        <dd>
         <a href="#Header">
          type Header
         </a>
        </dd>
        <dd>
         <a href="#Header.String">
          func (h Header) String() string
         </a>
        </dd>
        <dd>
         <a href="#Message">
          type Message
         </a>
        </dd>
        <dd>
         <a href="#Message.String">
          func (m *Message) String() string
         </a>
        </dd>
        <dd>
         <a href="#Metadata">
          type Metadata
         </a>
        </dd>
        <dd>
         <a href="#OAuthBearerToken">
          type OAuthBearerToken
         </a>
        </dd>
        <dd>
         <a href="#OAuthBearerTokenRefresh">
          type OAuthBearerTokenRefresh
         </a>
        </dd>
        <dd>
         <a href="#OAuthBearerTokenRefresh.String">
          func (o OAuthBearerTokenRefresh) String() string
         </a>
        </dd>
        <dd>
         <a href="#Offset">
          type Offset
         </a>
        </dd>
        <dd>
         <a href="#NewOffset">
          func NewOffset(offset interface{}) (Offset, error)
         </a>
        </dd>
        <dd>
         <a href="#OffsetTail">
          func OffsetTail(relativeOffset Offset) Offset
         </a>
        </dd>
        <dd>
         <a href="#Offset.Set">
          func (o *Offset) Set(offset interface{}) error
         </a>
        </dd>
        <dd>
         <a href="#Offset.String">
          func (o Offset) String() string
         </a>
        </dd>
        <dd>
         <a href="#OffsetsCommitted">
          type OffsetsCommitted
         </a>
        </dd>
        <dd>
         <a href="#OffsetsCommitted.String">
          func (o OffsetsCommitted) String() string
         </a>
        </dd>
        <dd>
         <a href="#PartitionEOF">
          type PartitionEOF
         </a>
        </dd>
        <dd>
         <a href="#PartitionEOF.String">
          func (p PartitionEOF) String() string
         </a>
        </dd>
        <dd>
         <a href="#PartitionMetadata">
          type PartitionMetadata
         </a>
        </dd>
        <dd>
         <a href="#PartitionsSpecification">
          type PartitionsSpecification
         </a>
        </dd>
        <dd>
         <a href="#Producer">
          type Producer
         </a>
        </dd>
        <dd>
         <a href="#NewProducer">
          func NewProducer(conf *ConfigMap) (*Producer, error)
         </a>
        </dd>
        <dd>
         <a href="#Producer.Close">
          func (p *Producer) Close()
         </a>
        </dd>
        <dd>
         <a href="#Producer.Events">
          func (p *Producer) Events() chan Event
         </a>
        </dd>
        <dd>
         <a href="#Producer.Flush">
          func (p *Producer) Flush(timeoutMs int) int
         </a>
        </dd>
        <dd>
         <a href="#Producer.GetFatalError">
          func (p *Producer) GetFatalError() error
         </a>
        </dd>
        <dd>
         <a href="#Producer.GetMetadata">
          func (p *Producer) GetMetadata(topic *string, allTopics bool, timeoutMs int) (*Metadata, error)
         </a>
        </dd>
        <dd>
         <a href="#Producer.Len">
          func (p *Producer) Len() int
         </a>
        </dd>
        <dd>
         <a href="#Producer.OffsetsForTimes">
          func (p *Producer) OffsetsForTimes(times []TopicPartition, timeoutMs int) (offsets []TopicPartition, err error)
         </a>
        </dd>
        <dd>
         <a href="#Producer.Produce">
          func (p *Producer) Produce(msg *Message, deliveryChan chan Event) error
         </a>
        </dd>
        <dd>
         <a href="#Producer.ProduceChannel">
          func (p *Producer) ProduceChannel() chan *Message
         </a>
        </dd>
        <dd>
         <a href="#Producer.QueryWatermarkOffsets">
          func (p *Producer) QueryWatermarkOffsets(topic string, partition int32, timeoutMs int) (low, high int64, err error)
         </a>
        </dd>
        <dd>
         <a href="#Producer.SetOAuthBearerToken">
          func (p *Producer) SetOAuthBearerToken(oauthBearerToken OAuthBearerToken) error
         </a>
        </dd>
        <dd>
         <a href="#Producer.SetOAuthBearerTokenFailure">
          func (p *Producer) SetOAuthBearerTokenFailure(errstr string) error
         </a>
        </dd>
        <dd>
         <a href="#Producer.String">
          func (p *Producer) String() string
         </a>
        </dd>
        <dd>
         <a href="#Producer.TestFatalError">
          func (p *Producer) TestFatalError(code ErrorCode, str string) ErrorCode
         </a>
        </dd>
        <dd>
         <a href="#RebalanceCb">
          type RebalanceCb
         </a>
        </dd>
        <dd>
         <a href="#ResourceType">
          type ResourceType
         </a>
        </dd>
        <dd>
         <a href="#ResourceTypeFromString">
          func ResourceTypeFromString(typeString string) (ResourceType, error)
         </a>
        </dd>
        <dd>
         <a href="#ResourceType.String">
          func (t ResourceType) String() string
         </a>
        </dd>
        <dd>
         <a href="#RevokedPartitions">
          type RevokedPartitions
         </a>
        </dd>
        <dd>
         <a href="#RevokedPartitions.String">
          func (e RevokedPartitions) String() string
         </a>
        </dd>
        <dd>
         <a href="#Stats">
          type Stats
         </a>
        </dd>
        <dd>
         <a href="#Stats.String">
          func (e Stats) String() string
         </a>
        </dd>
        <dd>
         <a href="#TimestampType">
          type TimestampType
         </a>
        </dd>
        <dd>
         <a href="#TimestampType.String">
          func (t TimestampType) String() string
         </a>
        </dd>
        <dd>
         <a href="#TopicMetadata">
          type TopicMetadata
         </a>
        </dd>
        <dd>
         <a href="#TopicPartition">
          type TopicPartition
         </a>
        </dd>
        <dd>
         <a href="#TopicPartition.String">
          func (p TopicPartition) String() string
         </a>
        </dd>
        <dd>
         <a href="#TopicPartitions">
          type TopicPartitions
         </a>
        </dd>
        <dd>
         <a href="#TopicPartitions.Len">
          func (tps TopicPartitions) Len() int
         </a>
        </dd>
        <dd>
         <a href="#TopicPartitions.Less">
          func (tps TopicPartitions) Less(i, j int) bool
         </a>
        </dd>
        <dd>
         <a href="#TopicPartitions.Swap">
          func (tps TopicPartitions) Swap(i, j int)
         </a>
        </dd>
        <dd>
         <a href="#TopicResult">
          type TopicResult
         </a>
        </dd>
        <dd>
         <a href="#TopicResult.String">
          func (t TopicResult) String() string
         </a>
        </dd>
        <dd>
         <a href="#TopicSpecification">
          type TopicSpecification
         </a>
        </dd>
       </dl>
      </div>
      <!-- #manual-nav -->
      <h3>
       Package files
      </h3>
      <p>
       <span style="font-size:90%">
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/00version.go">
         00version.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go">
         adminapi.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go">
         adminoptions.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/build_dynamic.go">
         build_dynamic.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/config.go">
         config.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go">
         consumer.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go">
         error.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go">
         event.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/generated_errors.go">
         generated_errors.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/handle.go">
         handle.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/header.go">
         header.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go">
         kafka.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/message.go">
         message.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/metadata.go">
         metadata.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/misc.go">
         misc.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/offset.go">
         offset.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go">
         producer.go
        </a>
        <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/testhelpers.go">
         testhelpers.go
        </a>
       </span>
      </p>
     </div>
     <!-- .expanded -->
    </div>
    <!-- #pkg-index -->
    <div class="toggle" id="pkg-callgraph" style="display: none">
     <div class="collapsed">
      <h2 class="toggleButton" title="Click to show Internal Call Graph section">
       Internal call graph ▹
      </h2>
     </div>
     <!-- .expanded -->
     <div class="expanded">
      <h2 class="toggleButton" title="Click to hide Internal Call Graph section">
       Internal call graph ▾
      </h2>
      <p>
       In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
      </p>
      <p>
       The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
      </p>
      <p>
       Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring
       <code>
        func
       </code>
       token.
      </p>
      <p>
       Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
      </p>
      <!-- Zero means show all package entry points. -->
      <ul class="treeview" id="callgraph-0" style="margin-left: 0.5in">
      </ul>
     </div>
    </div>
    <!-- #pkg-callgraph -->
    <h2 id="pkg-constants">
     Constants
    </h2>
    <pre>const (
    <span class="comment">// ResourceUnknown - Unknown</span>
    <span id="ResourceUnknown">ResourceUnknown</span> = <a href="#ResourceType">ResourceType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESOURCE_UNKNOWN">RD_KAFKA_RESOURCE_UNKNOWN</a>)
    <span class="comment">// ResourceAny - match any resource type (DescribeConfigs)</span>
    <span id="ResourceAny">ResourceAny</span> = <a href="#ResourceType">ResourceType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESOURCE_ANY">RD_KAFKA_RESOURCE_ANY</a>)
    <span class="comment">// ResourceTopic - Topic</span>
    <span id="ResourceTopic">ResourceTopic</span> = <a href="#ResourceType">ResourceType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESOURCE_TOPIC">RD_KAFKA_RESOURCE_TOPIC</a>)
    <span class="comment">// ResourceGroup - Group</span>
    <span id="ResourceGroup">ResourceGroup</span> = <a href="#ResourceType">ResourceType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESOURCE_GROUP">RD_KAFKA_RESOURCE_GROUP</a>)
    <span class="comment">// ResourceBroker - Broker</span>
    <span id="ResourceBroker">ResourceBroker</span> = <a href="#ResourceType">ResourceType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESOURCE_BROKER">RD_KAFKA_RESOURCE_BROKER</a>)
)</pre>
    <pre>const (
    <span class="comment">// ConfigSourceUnknown is the default value</span>
    <span id="ConfigSourceUnknown">ConfigSourceUnknown</span> = <a href="#ConfigSource">ConfigSource</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG">RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG</a>)
    <span class="comment">// ConfigSourceDynamicTopic is dynamic topic config that is configured for a specific topic</span>
    <span id="ConfigSourceDynamicTopic">ConfigSourceDynamicTopic</span> = <a href="#ConfigSource">ConfigSource</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG</a>)
    <span class="comment">// ConfigSourceDynamicBroker is dynamic broker config that is configured for a specific broker</span>
    <span id="ConfigSourceDynamicBroker">ConfigSourceDynamicBroker</span> = <a href="#ConfigSource">ConfigSource</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG</a>)
    <span class="comment">// ConfigSourceDynamicDefaultBroker is dynamic broker config that is configured as default for all brokers in the cluster</span>
    <span id="ConfigSourceDynamicDefaultBroker">ConfigSourceDynamicDefaultBroker</span> = <a href="#ConfigSource">ConfigSource</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG</a>)
    <span class="comment">// ConfigSourceStaticBroker is static broker config provided as broker properties at startup (e.g. from server.properties file)</span>
    <span id="ConfigSourceStaticBroker">ConfigSourceStaticBroker</span> = <a href="#ConfigSource">ConfigSource</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG">RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG</a>)
    <span class="comment">// ConfigSourceDefault is built-in default configuration for configs that have a default value</span>
    <span id="ConfigSourceDefault">ConfigSourceDefault</span> = <a href="#ConfigSource">ConfigSource</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG">RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG</a>)
)</pre>
    <pre>const (
    <span class="comment">// TimestampNotAvailable indicates no timestamp was set, or not available due to lacking broker support</span>
    <span id="TimestampNotAvailable">TimestampNotAvailable</span> = <a href="#TimestampType">TimestampType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_TIMESTAMP_NOT_AVAILABLE">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</a>)
    <span class="comment">// TimestampCreateTime indicates timestamp set by producer (source time)</span>
    <span id="TimestampCreateTime">TimestampCreateTime</span> = <a href="#TimestampType">TimestampType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_TIMESTAMP_CREATE_TIME">RD_KAFKA_TIMESTAMP_CREATE_TIME</a>)
    <span class="comment">// TimestampLogAppendTime indicates timestamp set set by broker (store time)</span>
    <span id="TimestampLogAppendTime">TimestampLogAppendTime</span> = <a href="#TimestampType">TimestampType</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</a>)
)</pre>
    <pre>const (
    <span class="comment">// AlterOperationSet sets/overwrites the configuration setting.</span>
    <span id="AlterOperationSet">AlterOperationSet</span> = <a href="//golang.org/pkg/builtin/#iota">iota</a>
)</pre>
    <p>
     OffsetBeginning represents the earliest offset (logical)
    </p>
    <pre>const <span id="OffsetBeginning">OffsetBeginning</span> = <a href="#Offset">Offset</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_OFFSET_BEGINNING">RD_KAFKA_OFFSET_BEGINNING</a>)</pre>
    <p>
     OffsetEnd represents the latest offset (logical)
    </p>
    <pre>const <span id="OffsetEnd">OffsetEnd</span> = <a href="#Offset">Offset</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_OFFSET_END">RD_KAFKA_OFFSET_END</a>)</pre>
    <p>
     OffsetInvalid represents an invalid/unspecified offset
    </p>
    <pre>const <span id="OffsetInvalid">OffsetInvalid</span> = <a href="#Offset">Offset</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_OFFSET_INVALID">RD_KAFKA_OFFSET_INVALID</a>)</pre>
    <p>
     OffsetStored represents a stored offset
    </p>
    <pre>const <span id="OffsetStored">OffsetStored</span> = <a href="#Offset">Offset</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_OFFSET_STORED">RD_KAFKA_OFFSET_STORED</a>)</pre>
    <p>
     PartitionAny represents any partition (for partitioning),
or unspecified value (for all other cases)
    </p>
    <pre>const <span id="PartitionAny">PartitionAny</span> = <a href="//golang.org/pkg/builtin/#int32">int32</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_PARTITION_UA">RD_KAFKA_PARTITION_UA</a>)</pre>
    <h2 id="LibraryVersion">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=9694:9729#L250">
      LibraryVersion
     </a>
     <a class="permalink" href="#LibraryVersion">
      ¶
     </a>
    </h2>
    <pre>func LibraryVersion() (<a href="//golang.org/pkg/builtin/#int">int</a>, <a href="//golang.org/pkg/builtin/#string">string</a>)</pre>
    <p>
     LibraryVersion returns the underlying librdkafka library version as a
(version_int, version_str) tuple.
    </p>
    <h2 id="AdminClient">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=1379:1480#L45">
      AdminClient
     </a>
     <a class="permalink" href="#AdminClient">
      ¶
     </a>
    </h2>
    <p>
     AdminClient is derived from an existing Producer or Consumer
    </p>
    <pre>type AdminClient struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="NewAdminClient">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=30913:30971#L901">
      NewAdminClient
     </a>
     <a class="permalink" href="#NewAdminClient">
      ¶
     </a>
    </h3>
    <pre>func NewAdminClient(conf *<a href="#ConfigMap">ConfigMap</a>) (*<a href="#AdminClient">AdminClient</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     NewAdminClient creats a new AdminClient instance with a new underlying client instance
    </p>
    <h3 id="NewAdminClientFromConsumer">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=32436:32508#L950">
      NewAdminClientFromConsumer
     </a>
     <a class="permalink" href="#NewAdminClientFromConsumer">
      ¶
     </a>
    </h3>
    <pre>func NewAdminClientFromConsumer(c *<a href="#Consumer">Consumer</a>) (a *<a href="#AdminClient">AdminClient</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     NewAdminClientFromConsumer derives a new AdminClient from an existing Consumer instance.
The AdminClient will use the same configuration and connections as the parent instance.
    </p>
    <h3 id="NewAdminClientFromProducer">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=31972:32044#L937">
      NewAdminClientFromProducer
     </a>
     <a class="permalink" href="#NewAdminClientFromProducer">
      ¶
     </a>
    </h3>
    <pre>func NewAdminClientFromProducer(p *<a href="#Producer">Producer</a>) (a *<a href="#AdminClient">AdminClient</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     NewAdminClientFromProducer derives a new AdminClient from an existing Producer instance.
The AdminClient will use the same configuration and connections as the parent instance.
    </p>
    <h3 id="AdminClient.AlterConfigs">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=23488:23650#L687">
      AlterConfigs
     </a>
     <a class="permalink" href="#AdminClient.AlterConfigs">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) AlterConfigs(ctx <a href="//golang.org/pkg/context/">context</a>.<a href="//golang.org/pkg/context/#Context">Context</a>, resources []<a href="#ConfigResource">ConfigResource</a>, options ...<a href="#AlterConfigsAdminOption">AlterConfigsAdminOption</a>) (result []<a href="#ConfigResourceResult">ConfigResourceResult</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     AlterConfigs alters/updates cluster resource configuration.
    </p>
    <p>
     Updates are not transactional so they may succeed for a subset
of the provided resources while others fail.
The configuration for a particular resource is updated atomically,
replacing values using the provided ConfigEntrys and reverting
unspecified ConfigEntrys to their default values.
    </p>
    <p>
     Requires broker version &gt;=0.11.0.0
    </p>
    <p>
     AlterConfigs will replace all existing configuration for
the provided resources with the new configuration given,
reverting all other configuration to their default values.
    </p>
    <p>
     Multiple resources and resource types may be set, but at most one
resource of type ResourceBroker is allowed per call since these
resource requests must be sent to the broker specified in the resource.
    </p>
    <h3 id="AdminClient.Close">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=30637:30666#L888">
      Close
     </a>
     <a class="permalink" href="#AdminClient.Close">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) Close()</pre>
    <p>
     Close an AdminClient instance.
    </p>
    <h3 id="AdminClient.CreatePartitions">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=20268:20439#L597">
      CreatePartitions
     </a>
     <a class="permalink" href="#AdminClient.CreatePartitions">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) CreatePartitions(ctx <a href="//golang.org/pkg/context/">context</a>.<a href="//golang.org/pkg/context/#Context">Context</a>, partitions []<a href="#PartitionsSpecification">PartitionsSpecification</a>, options ...<a href="#CreatePartitionsAdminOption">CreatePartitionsAdminOption</a>) (result []<a href="#TopicResult">TopicResult</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     CreatePartitions creates additional partitions for topics.
    </p>
    <h3 id="AdminClient.CreateTopics">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=14566:14720#L421">
      CreateTopics
     </a>
     <a class="permalink" href="#AdminClient.CreateTopics">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) CreateTopics(ctx <a href="//golang.org/pkg/context/">context</a>.<a href="//golang.org/pkg/context/#Context">Context</a>, topics []<a href="#TopicSpecification">TopicSpecification</a>, options ...<a href="#CreateTopicsAdminOption">CreateTopicsAdminOption</a>) (result []<a href="#TopicResult">TopicResult</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     CreateTopics creates topics in cluster.
    </p>
    <p>
     The list of TopicSpecification objects define the per-topic partition count, replicas, etc.
    </p>
    <p>
     Topic creation is non-atomic and may succeed for some topics but fail for others,
make sure to check the result for topic-specific errors.
    </p>
    <p>
     Note: TopicSpecification is analogous to NewTopic in the Java Topic Admin API.
    </p>
    <h3 id="AdminClient.DeleteTopics">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=18495:18637#L539">
      DeleteTopics
     </a>
     <a class="permalink" href="#AdminClient.DeleteTopics">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) DeleteTopics(ctx <a href="//golang.org/pkg/context/">context</a>.<a href="//golang.org/pkg/context/#Context">Context</a>, topics []<a href="//golang.org/pkg/builtin/#string">string</a>, options ...<a href="#DeleteTopicsAdminOption">DeleteTopicsAdminOption</a>) (result []<a href="#TopicResult">TopicResult</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     DeleteTopics deletes a batch of topics.
    </p>
    <p>
     This operation is not transactional and may succeed for a subset of topics while
failing others.
It may take several seconds after the DeleteTopics result returns success for
all the brokers to become aware that the topics are gone. During this time,
topic metadata and configuration may continue to return information about deleted topics.
    </p>
    <p>
     Requires broker version &gt;= 0.10.1.0
    </p>
    <h3 id="AdminClient.DescribeConfigs">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=26690:26858#L785">
      DescribeConfigs
     </a>
     <a class="permalink" href="#AdminClient.DescribeConfigs">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) DescribeConfigs(ctx <a href="//golang.org/pkg/context/">context</a>.<a href="//golang.org/pkg/context/#Context">Context</a>, resources []<a href="#ConfigResource">ConfigResource</a>, options ...<a href="#DescribeConfigsAdminOption">DescribeConfigsAdminOption</a>) (result []<a href="#ConfigResourceResult">ConfigResourceResult</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     DescribeConfigs retrieves configuration for cluster resources.
    </p>
    <p>
     The returned configuration includes default values, use
ConfigEntryResult.IsDefault or ConfigEntryResult.Source to distinguish
default values from manually configured settings.
    </p>
    <p>
     The value of config entries where .IsSensitive is true
will always be nil to avoid disclosing sensitive
information, such as security settings.
    </p>
    <p>
     Configuration entries where .IsReadOnly is true can't be modified
(with AlterConfigs).
    </p>
    <p>
     Synonym configuration entries are returned if the broker supports
it (broker version &gt;= 1.1.0). See .Synonyms.
    </p>
    <p>
     Requires broker version &gt;=0.11.0.0
    </p>
    <p>
     Multiple resources and resource types may be requested, but at most
one resource of type ResourceBroker is allowed per call
since these resource requests must be sent to the broker specified
in the resource.
    </p>
    <h3 id="AdminClient.GetMetadata">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=28871:28969#L848">
      GetMetadata
     </a>
     <a class="permalink" href="#AdminClient.GetMetadata">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) GetMetadata(topic *<a href="//golang.org/pkg/builtin/#string">string</a>, allTopics <a href="//golang.org/pkg/builtin/#bool">bool</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (*<a href="#Metadata">Metadata</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     GetMetadata queries broker for cluster and topic metadata.
If topic is non-nil only information about that topic is returned, else if
allTopics is false only information about locally used topics is returned,
else information about all topics is returned.
GetMetadata is equivalent to listTopics, describeTopics and describeCluster in the Java API.
    </p>
    <h3 id="AdminClient.SetOAuthBearerToken">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=29895:29977#L872">
      SetOAuthBearerToken
     </a>
     <a class="permalink" href="#AdminClient.SetOAuthBearerToken">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) SetOAuthBearerToken(oauthBearerToken <a href="#OAuthBearerToken">OAuthBearerToken</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetOAuthBearerToken sets the the data to be transmitted
to a broker during SASL/OAUTHBEARER authentication. It will return nil
on success, otherwise an error if:
1) the token data is invalid (meaning an expiration time in the past
or either a token value or an extension key or value that does not meet
the regular expression requirements as per
     <a href="https://tools.ietf.org/html/rfc7628#section-3.1">
      https://tools.ietf.org/html/rfc7628#section-3.1
     </a>
     );
2) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;
3) SASL/OAUTHBEARER is supported but is not configured as the client's
authentication mechanism.
    </p>
    <h3 id="AdminClient.SetOAuthBearerTokenFailure">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=30476:30545#L883">
      SetOAuthBearerTokenFailure
     </a>
     <a class="permalink" href="#AdminClient.SetOAuthBearerTokenFailure">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) SetOAuthBearerTokenFailure(errstr <a href="//golang.org/pkg/builtin/#string">string</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetOAuthBearerTokenFailure sets the error message describing why token
retrieval/setting failed; it also schedules a new token refresh event for 10
seconds later so the attempt may be retried. It will return nil on
success, otherwise an error if:
1) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;
2) SASL/OAUTHBEARER is supported but is not configured as the client's
authentication mechanism.
    </p>
    <h3 id="AdminClient.String">
     func (*AdminClient)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=29095:29132#L853">
      String
     </a>
     <a class="permalink" href="#AdminClient.String">
      ¶
     </a>
    </h3>
    <pre>func (a *<a href="#AdminClient">AdminClient</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human readable name for an AdminClient instance
    </p>
    <h2 id="AdminOption">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=6795:6875#L236">
      AdminOption
     </a>
     <a class="permalink" href="#AdminOption">
      ¶
     </a>
    </h2>
    <p>
     AdminOption is a generic type not to be used directly.
    </p>
    <p>
     See CreateTopicsAdminOption et.al.
    </p>
    <pre>type AdminOption interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="AdminOptionOperationTimeout">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=1231:1307#L33">
      AdminOptionOperationTimeout
     </a>
     <a class="permalink" href="#AdminOptionOperationTimeout">
      ¶
     </a>
    </h2>
    <p>
     AdminOptionOperationTimeout sets the broker's operation timeout, such as the
timeout for CreateTopics to complete the creation of topics on the controller
before returning a result to the application.
    </p>
    <p>
     CreateTopics, DeleteTopics, CreatePartitions:
a value 0 will return immediately after triggering topic
creation, while &gt; 0 will wait this long for topic creation to propagate
in cluster.
    </p>
    <p>
     Default: 0 (return immediately).
    </p>
    <p>
     Valid for CreateTopics, DeleteTopics, CreatePartitions.
    </p>
    <pre>type AdminOptionOperationTimeout struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="SetAdminOperationTimeout">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=2578:2657#L79">
      SetAdminOperationTimeout
     </a>
     <a class="permalink" href="#SetAdminOperationTimeout">
      ¶
     </a>
    </h3>
    <pre>func SetAdminOperationTimeout(t <a href="//golang.org/pkg/time/">time</a>.<a href="//golang.org/pkg/time/#Duration">Duration</a>) (ao <a href="#AdminOptionOperationTimeout">AdminOptionOperationTimeout</a>)</pre>
    <p>
     SetAdminOperationTimeout sets the broker's operation timeout, such as the
timeout for CreateTopics to complete the creation of topics on the controller
before returning a result to the application.
    </p>
    <p>
     CreateTopics, DeleteTopics, CreatePartitions:
a value 0 will return immediately after triggering topic
creation, while &gt; 0 will wait this long for topic creation to propagate
in cluster.
    </p>
    <p>
     Default: 0 (return immediately).
    </p>
    <p>
     Valid for CreateTopics, DeleteTopics, CreatePartitions.
    </p>
    <h2 id="AdminOptionRequestTimeout">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=2931:3005#L91">
      AdminOptionRequestTimeout
     </a>
     <a class="permalink" href="#AdminOptionRequestTimeout">
      ¶
     </a>
    </h2>
    <p>
     AdminOptionRequestTimeout sets the overall request timeout, including broker
lookup, request transmission, operation time on broker, and response.
    </p>
    <p>
     Default: `socket.timeout.ms`.
    </p>
    <p>
     Valid for all Admin API methods.
    </p>
    <pre>type AdminOptionRequestTimeout struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="SetAdminRequestTimeout">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=4077:4152#L135">
      SetAdminRequestTimeout
     </a>
     <a class="permalink" href="#SetAdminRequestTimeout">
      ¶
     </a>
    </h3>
    <pre>func SetAdminRequestTimeout(t <a href="//golang.org/pkg/time/">time</a>.<a href="//golang.org/pkg/time/#Duration">Duration</a>) (ao <a href="#AdminOptionRequestTimeout">AdminOptionRequestTimeout</a>)</pre>
    <p>
     SetAdminRequestTimeout sets the overall request timeout, including broker
lookup, request transmission, operation time on broker, and response.
    </p>
    <p>
     Default: `socket.timeout.ms`.
    </p>
    <p>
     Valid for all Admin API methods.
    </p>
    <h2 id="AdminOptionValidateOnly">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=4423:4486#L147">
      AdminOptionValidateOnly
     </a>
     <a class="permalink" href="#AdminOptionValidateOnly">
      ¶
     </a>
    </h2>
    <p>
     AdminOptionValidateOnly tells the broker to only validate the request,
without performing the requested operation (create topics, etc).
    </p>
    <p>
     Default: false.
    </p>
    <p>
     Valid for CreateTopics, CreatePartitions, AlterConfigs
    </p>
    <pre>type AdminOptionValidateOnly struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="SetAdminValidateOnly">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=5410:5483#L187">
      SetAdminValidateOnly
     </a>
     <a class="permalink" href="#SetAdminValidateOnly">
      ¶
     </a>
    </h3>
    <pre>func SetAdminValidateOnly(validateOnly <a href="//golang.org/pkg/builtin/#bool">bool</a>) (ao <a href="#AdminOptionValidateOnly">AdminOptionValidateOnly</a>)</pre>
    <p>
     SetAdminValidateOnly tells the broker to only validate the request,
without performing the requested operation (create topics, etc).
    </p>
    <p>
     Default: false.
    </p>
    <p>
     Valid for CreateTopics, DeleteTopics, CreatePartitions, AlterConfigs
    </p>
    <h2 id="AlterConfigsAdminOption">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=6375:6491#L220">
      AlterConfigsAdminOption
     </a>
     <a class="permalink" href="#AlterConfigsAdminOption">
      ¶
     </a>
    </h2>
    <p>
     AlterConfigsAdminOption - see setters.
    </p>
    <p>
     See SetAdminRequestTimeout, SetAdminValidateOnly, SetAdminIncremental.
    </p>
    <pre>type AlterConfigsAdminOption interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="AlterOperation">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=6824:6847#L188">
      AlterOperation
     </a>
     <a class="permalink" href="#AlterOperation">
      ¶
     </a>
    </h2>
    <p>
     AlterOperation specifies the operation to perform on the ConfigEntry.
Currently only AlterOperationSet.
    </p>
    <pre>type AlterOperation <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <h3 id="AlterOperation.String">
     func (AlterOperation)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=7024:7063#L196">
      String
     </a>
     <a class="permalink" href="#AlterOperation.String">
      ¶
     </a>
    </h3>
    <pre>func (o <a href="#AlterOperation">AlterOperation</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns the human-readable representation of an AlterOperation
    </p>
    <h2 id="AssignedPartitions">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2640:2703#L92">
      AssignedPartitions
     </a>
     <a class="permalink" href="#AssignedPartitions">
      ¶
     </a>
    </h2>
    <p>
     AssignedPartitions consumer group rebalance event: assigned partition set
    </p>
    <pre>type AssignedPartitions struct {
<span id="AssignedPartitions.Partitions"></span>    Partitions []<a href="#TopicPartition">TopicPartition</a>
}
</pre>
    <h3 id="AssignedPartitions.String">
     func (AssignedPartitions)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2705:2748#L96">
      String
     </a>
     <a class="permalink" href="#AssignedPartitions.String">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#AssignedPartitions">AssignedPartitions</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="BrokerMetadata">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/metadata.go?s=1266:1331#L37">
      BrokerMetadata
     </a>
     <a class="permalink" href="#BrokerMetadata">
      ¶
     </a>
    </h2>
    <p>
     BrokerMetadata contains per-broker metadata
    </p>
    <pre>type BrokerMetadata struct {
<span id="BrokerMetadata.ID"></span>    ID   <a href="//golang.org/pkg/builtin/#int32">int32</a>
<span id="BrokerMetadata.Host"></span>    Host <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="BrokerMetadata.Port"></span>    Port <a href="//golang.org/pkg/builtin/#int">int</a>
}
</pre>
    <h2 id="ConfigEntry">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=7250:7477#L206">
      ConfigEntry
     </a>
     <a class="permalink" href="#ConfigEntry">
      ¶
     </a>
    </h2>
    <p>
     ConfigEntry holds parameters for altering a resource's configuration.
    </p>
    <pre>type ConfigEntry struct {
<span id="ConfigEntry.Name"></span>    <span class="comment">// Name of configuration entry, e.g., topic configuration property name.</span>
    Name <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="ConfigEntry.Value"></span>    <span class="comment">// Value of configuration entry.</span>
    Value <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="ConfigEntry.Operation"></span>    <span class="comment">// Operation to perform on the entry.</span>
    Operation <a href="#AlterOperation">AlterOperation</a>
}
</pre>
    <h3 id="StringMapToConfigEntries">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=7630:7728#L217">
      StringMapToConfigEntries
     </a>
     <a class="permalink" href="#StringMapToConfigEntries">
      ¶
     </a>
    </h3>
    <pre>func StringMapToConfigEntries(stringMap map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="//golang.org/pkg/builtin/#string">string</a>, operation <a href="#AlterOperation">AlterOperation</a>) []<a href="#ConfigEntry">ConfigEntry</a></pre>
    <p>
     StringMapToConfigEntries creates a new map of ConfigEntry objects from the
provided string map. The AlterOperation is set on each created entry.
    </p>
    <h3 id="ConfigEntry.String">
     func (ConfigEntry)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=7959:7995#L228">
      String
     </a>
     <a class="permalink" href="#ConfigEntry.String">
      ¶
     </a>
    </h3>
    <pre>func (c <a href="#ConfigEntry">ConfigEntry</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human-readable representation of a ConfigEntry.
    </p>
    <h2 id="ConfigEntryResult">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=8175:8908#L234">
      ConfigEntryResult
     </a>
     <a class="permalink" href="#ConfigEntryResult">
      ¶
     </a>
    </h2>
    <p>
     ConfigEntryResult contains the result of a single configuration entry from a
DescribeConfigs request.
    </p>
    <pre>type ConfigEntryResult struct {
<span id="ConfigEntryResult.Name"></span>    <span class="comment">// Name of configuration entry, e.g., topic configuration property name.</span>
    Name <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="ConfigEntryResult.Value"></span>    <span class="comment">// Value of configuration entry.</span>
    Value <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="ConfigEntryResult.Source"></span>    <span class="comment">// Source indicates the configuration source.</span>
    Source <a href="#ConfigSource">ConfigSource</a>
<span id="ConfigEntryResult.IsReadOnly"></span>    <span class="comment">// IsReadOnly indicates whether the configuration entry can be altered.</span>
    IsReadOnly <a href="//golang.org/pkg/builtin/#bool">bool</a>
<span id="ConfigEntryResult.IsSensitive"></span>    <span class="comment">// IsSensitive indicates whether the configuration entry contains sensitive information, in which case the value will be unset.</span>
    IsSensitive <a href="//golang.org/pkg/builtin/#bool">bool</a>
<span id="ConfigEntryResult.IsSynonym"></span>    <span class="comment">// IsSynonym indicates whether the configuration entry is a synonym for another configuration property.</span>
    IsSynonym <a href="//golang.org/pkg/builtin/#bool">bool</a>
<span id="ConfigEntryResult.Synonyms"></span>    <span class="comment">// Synonyms contains a map of configuration entries that are synonyms to this configuration entry.</span>
    Synonyms map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="#ConfigEntryResult">ConfigEntryResult</a>
}
</pre>
    <h3 id="ConfigEntryResult.String">
     func (ConfigEntryResult)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=8984:9026#L252">
      String
     </a>
     <a class="permalink" href="#ConfigEntryResult.String">
      ¶
     </a>
    </h3>
    <pre>func (c <a href="#ConfigEntryResult">ConfigEntryResult</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human-readable representation of a ConfigEntryResult.
    </p>
    <h2 id="ConfigMap">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/config.go?s=1397:1434#L36">
      ConfigMap
     </a>
     <a class="permalink" href="#ConfigMap">
      ¶
     </a>
    </h2>
    <p>
     ConfigMap is a map contaning standard librdkafka configuration properties as documented in:
     <a href="https://github.com/edenhill/librdkafka/tree/master/CONFIGURATION.md">
      https://github.com/edenhill/librdkafka/tree/master/CONFIGURATION.md
     </a>
    </p>
    <p>
     The special property "default.topic.config" (optional) is a ConfigMap
containing default topic configuration properties.
    </p>
    <p>
     The use of "default.topic.config" is deprecated,
topic configuration properties shall be specified in the standard ConfigMap.
For backwards compatibility, "default.topic.config" (if supplied)
takes precedence.
    </p>
    <pre>type ConfigMap map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="#ConfigValue">ConfigValue</a></pre>
    <h3 id="ConfigMap.Get">
     func (ConfigMap)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/config.go?s=6796:6871#L237">
      Get
     </a>
     <a class="permalink" href="#ConfigMap.Get">
      ¶
     </a>
    </h3>
    <pre>func (m <a href="#ConfigMap">ConfigMap</a>) Get(key <a href="//golang.org/pkg/builtin/#string">string</a>, defval <a href="#ConfigValue">ConfigValue</a>) (<a href="#ConfigValue">ConfigValue</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Get finds the given key in the ConfigMap and returns its value.
If the key is not found `defval` is returned.
If the key is found but the type does not match that of `defval` (unless nil)
an ErrInvalidArg error is returned.
    </p>
    <h3 id="ConfigMap.Set">
     func (ConfigMap)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/config.go?s=2065:2104#L58">
      Set
     </a>
     <a class="permalink" href="#ConfigMap.Set">
      ¶
     </a>
    </h3>
    <pre>func (m <a href="#ConfigMap">ConfigMap</a>) Set(kv <a href="//golang.org/pkg/builtin/#string">string</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     Set implements flag.Set (command line argument parser) as a convenience
for `-X key=value` config.
    </p>
    <h3 id="ConfigMap.SetKey">
     func (ConfigMap)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/config.go?s=1622:1684#L42">
      SetKey
     </a>
     <a class="permalink" href="#ConfigMap.SetKey">
      ¶
     </a>
    </h3>
    <pre>func (m <a href="#ConfigMap">ConfigMap</a>) SetKey(key <a href="//golang.org/pkg/builtin/#string">string</a>, value <a href="#ConfigValue">ConfigValue</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetKey sets configuration property key to value.
    </p>
    <p>
     For user convenience a key prefixed with {topic}. will be
set on the "default.topic.config" sub-map, this use is deprecated.
    </p>
    <h2 id="ConfigResource">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=6146:6541#L169">
      ConfigResource
     </a>
     <a class="permalink" href="#ConfigResource">
      ¶
     </a>
    </h2>
    <p>
     ConfigResource holds parameters for altering an Apache Kafka configuration resource
    </p>
    <pre>type ConfigResource struct {
<span id="ConfigResource.Type"></span>    <span class="comment">// Type of resource to set.</span>
    Type <a href="#ResourceType">ResourceType</a>
<span id="ConfigResource.Name"></span>    <span class="comment">// Name of resource to set.</span>
    Name <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="ConfigResource.Config"></span>    <span class="comment">// Config entries to set.</span>
    <span class="comment">// Configuration updates are atomic, any configuration property not provided</span>
    <span class="comment">// here will be reverted (by the broker) to its default value.</span>
    <span class="comment">// Use DescribeConfigs to retrieve the list of current configuration entry values.</span>
    Config []<a href="#ConfigEntry">ConfigEntry</a>
}
</pre>
    <h3 id="ConfigResource.String">
     func (ConfigResource)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=6613:6652#L182">
      String
     </a>
     <a class="permalink" href="#ConfigResource.String">
      ¶
     </a>
    </h3>
    <pre>func (c <a href="#ConfigResource">ConfigResource</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human-readable representation of a ConfigResource
    </p>
    <h2 id="ConfigResourceResult">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=10154:10453#L285">
      ConfigResourceResult
     </a>
     <a class="permalink" href="#ConfigResourceResult">
      ¶
     </a>
    </h2>
    <p>
     ConfigResourceResult provides the result for a resource from a AlterConfigs or
DescribeConfigs request.
    </p>
    <pre>type ConfigResourceResult struct {
<span id="ConfigResourceResult.Type"></span>    <span class="comment">// Type of returned result resource.</span>
    Type <a href="#ResourceType">ResourceType</a>
<span id="ConfigResourceResult.Name"></span>    <span class="comment">// Name of returned result resource.</span>
    Name <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="ConfigResourceResult.Error"></span>    <span class="comment">// Error, if any, of returned result resource.</span>
    Error <a href="#Error">Error</a>
<span id="ConfigResourceResult.Config"></span>    <span class="comment">// Config entries, if any, of returned result resource.</span>
    Config map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="#ConfigEntryResult">ConfigEntryResult</a>
}
</pre>
    <h3 id="ConfigResourceResult.String">
     func (ConfigResourceResult)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=10532:10577#L297">
      String
     </a>
     <a class="permalink" href="#ConfigResourceResult.String">
      ¶
     </a>
    </h3>
    <pre>func (c <a href="#ConfigResourceResult">ConfigResourceResult</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human-readable representation of a ConfigResourceResult.
    </p>
    <h2 id="ConfigSource">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=4721:4742#L146">
      ConfigSource
     </a>
     <a class="permalink" href="#ConfigSource">
      ¶
     </a>
    </h2>
    <p>
     ConfigSource represents an Apache Kafka config source
    </p>
    <pre>type ConfigSource <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <h3 id="ConfigSource.String">
     func (ConfigSource)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=5937:5974#L164">
      String
     </a>
     <a class="permalink" href="#ConfigSource.String">
      ¶
     </a>
    </h3>
    <pre>func (t <a href="#ConfigSource">ConfigSource</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns the human-readable representation of a ConfigSource type
    </p>
    <h2 id="ConfigValue">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/config.go?s=846:874#L24">
      ConfigValue
     </a>
     <a class="permalink" href="#ConfigValue">
      ¶
     </a>
    </h2>
    <p>
     ConfigValue supports the following types:
    </p>
    <pre>bool, int, string, any type with the standard String() interface
</pre>
    <pre>type ConfigValue interface{}</pre>
    <h2 id="Consumer">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=1183:1420#L32">
      Consumer
     </a>
     <a class="permalink" href="#Consumer">
      ¶
     </a>
    </h2>
    <p>
     Consumer implements a High-level Apache Kafka Consumer instance
    </p>
    <pre>type Consumer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="NewConsumer">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=11363:11415#L356">
      NewConsumer
     </a>
     <a class="permalink" href="#NewConsumer">
      ¶
     </a>
    </h3>
    <pre>func NewConsumer(conf *<a href="#ConfigMap">ConfigMap</a>) (*<a href="#Consumer">Consumer</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     NewConsumer creates a new high-level Consumer instance.
    </p>
    <p>
     Supported special configuration properties:
    </p>
    <pre>go.application.rebalance.enable (bool, false) - Forward rebalancing responsibility to application via the Events() channel.
                                     If set to true the app must handle the AssignedPartitions and
                                     RevokedPartitions events and call Assign() and Unassign()
                                     respectively.
go.events.channel.enable (bool, false) - Enable the Events() channel. Messages and events will be pushed on the Events() channel and the Poll() interface will be disabled. (Experimental)
go.events.channel.size (int, 1000) - Events() channel size
</pre>
    <p>
     WARNING: Due to the buffering nature of channels (and queues in general) the
use of the events channel risks receiving outdated events and
messages. Minimizing go.events.channel.size reduces the risk
and number of outdated events and messages but does not eliminate
the factor completely. With a channel size of 1 at most one
event or message may be outdated.
    </p>
    <h3 id="Consumer.Assign">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=2856:2922#L89">
      Assign
     </a>
     <a class="permalink" href="#Consumer.Assign">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Assign(partitions []<a href="#TopicPartition">TopicPartition</a>) (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Assign an atomic set of partitions to consume.
This replaces the current assignment.
    </p>
    <h3 id="Consumer.Assignment">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=16944:17016#L528">
      Assignment
     </a>
     <a class="permalink" href="#Consumer.Assignment">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Assignment() (partitions []<a href="#TopicPartition">TopicPartition</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Assignment returns the current partition assignments
    </p>
    <h3 id="Consumer.Close">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=9771:9809#L316">
      Close
     </a>
     <a class="permalink" href="#Consumer.Close">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Close() (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Close Consumer instance.
The object is no longer usable after this call.
    </p>
    <h3 id="Consumer.Commit">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=5068:5121#L166">
      Commit
     </a>
     <a class="permalink" href="#Consumer.Commit">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Commit() ([]<a href="#TopicPartition">TopicPartition</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Commit offsets for currently assigned partitions
This is a blocking call.
Returns the committed offsets on success.
    </p>
    <h3 id="Consumer.CommitMessage">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=5285:5355#L173">
      CommitMessage
     </a>
     <a class="permalink" href="#Consumer.CommitMessage">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) CommitMessage(m *<a href="#Message">Message</a>) ([]<a href="#TopicPartition">TopicPartition</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     CommitMessage commits offset based on the provided message.
This is a blocking call.
Returns the committed offsets on success.
    </p>
    <h3 id="Consumer.CommitOffsets">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=5701:5785#L185">
      CommitOffsets
     </a>
     <a class="permalink" href="#Consumer.CommitOffsets">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) CommitOffsets(offsets []<a href="#TopicPartition">TopicPartition</a>) ([]<a href="#TopicPartition">TopicPartition</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     CommitOffsets commits the provided list of offsets
This is a blocking call.
Returns the committed offsets on success.
    </p>
    <h3 id="Consumer.Committed">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=17403:17513#L543">
      Committed
     </a>
     <a class="permalink" href="#Consumer.Committed">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Committed(partitions []<a href="#TopicPartition">TopicPartition</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (offsets []<a href="#TopicPartition">TopicPartition</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Committed retrieves committed offsets for the given set of partitions
    </p>
    <h3 id="Consumer.Events">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=8098:8136#L252">
      Events
     </a>
     <a class="permalink" href="#Consumer.Events">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Events() chan <a href="#Event">Event</a></pre>
    <p>
     Events returns the Events channel (if enabled)
    </p>
    <h3 id="Consumer.GetMetadata">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=14558:14653#L471">
      GetMetadata
     </a>
     <a class="permalink" href="#Consumer.GetMetadata">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) GetMetadata(topic *<a href="//golang.org/pkg/builtin/#string">string</a>, allTopics <a href="//golang.org/pkg/builtin/#bool">bool</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (*<a href="#Metadata">Metadata</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     GetMetadata queries broker for cluster and topic metadata.
If topic is non-nil only information about that topic is returned, else if
allTopics is false only information about locally used topics is returned,
else information about all topics is returned.
GetMetadata is equivalent to listTopics, describeTopics and describeCluster in the Java API.
    </p>
    <h3 id="Consumer.GetWatermarkOffsets">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=15358:15456#L484">
      GetWatermarkOffsets
     </a>
     <a class="permalink" href="#Consumer.GetWatermarkOffsets">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) GetWatermarkOffsets(topic <a href="//golang.org/pkg/builtin/#string">string</a>, partition <a href="//golang.org/pkg/builtin/#int32">int32</a>) (low, high <a href="//golang.org/pkg/builtin/#int64">int64</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     GetWatermarkOffsets returns the cached low and high offsets for the given topic
and partition.  The high offset is populated on every fetch response or via calling QueryWatermarkOffsets.
The low offset is populated every statistics.interval.ms if that value is set.
OffsetInvalid will be returned if there is no cached offset for either value.
    </p>
    <h3 id="Consumer.OffsetsForTimes">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=16113:16224#L502">
      OffsetsForTimes
     </a>
     <a class="permalink" href="#Consumer.OffsetsForTimes">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) OffsetsForTimes(times []<a href="#TopicPartition">TopicPartition</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (offsets []<a href="#TopicPartition">TopicPartition</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     OffsetsForTimes looks up offsets by timestamp for the given partitions.
    </p>
    <p>
     The returned offset for each partition is the earliest offset whose
timestamp is greater than or equal to the given timestamp in the
corresponding partition.
    </p>
    <p>
     The timestamps to query are represented as `.Offset` in the `times`
argument and the looked up offsets are represented as `.Offset` in the returned
`offsets` list.
    </p>
    <p>
     The function will block for at most timeoutMs milliseconds.
    </p>
    <p>
     Duplicate Topic+Partitions are not supported.
Per-partition errors may be returned in the `.Error` field.
    </p>
    <h3 id="Consumer.Pause">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=18078:18143#L559">
      Pause
     </a>
     <a class="permalink" href="#Consumer.Pause">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Pause(partitions []<a href="#TopicPartition">TopicPartition</a>) (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Pause consumption for the provided list of partitions
    </p>
    <p>
     Note that messages already enqueued on the consumer's Event channel
(if `go.events.channel.enable` has been set) will NOT be purged by
this call, set `go.events.channel.size` accordingly.
    </p>
    <h3 id="Consumer.Poll">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=7926:7978#L246">
      Poll
     </a>
     <a class="permalink" href="#Consumer.Poll">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Poll(timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (event <a href="#Event">Event</a>)</pre>
    <p>
     Poll the consumer for messages or events.
    </p>
    <h3 id="hdr-Will_block_for_at_most_timeoutMs_milliseconds">
     Will block for at most timeoutMs milliseconds
    </h3>
    <p>
     The following callbacks may be triggered:
    </p>
    <pre>Subscribe()'s rebalanceCb
</pre>
    <p>
     Returns nil on timeout, else an Event
    </p>
    <h3 id="Consumer.QueryWatermarkOffsets">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=14819:14934#L476">
      QueryWatermarkOffsets
     </a>
     <a class="permalink" href="#Consumer.QueryWatermarkOffsets">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) QueryWatermarkOffsets(topic <a href="//golang.org/pkg/builtin/#string">string</a>, partition <a href="//golang.org/pkg/builtin/#int32">int32</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (low, high <a href="//golang.org/pkg/builtin/#int64">int64</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     QueryWatermarkOffsets queries the broker for the low and high offsets for the given topic and partition.
    </p>
    <h3 id="Consumer.ReadMessage">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=8934:9005#L274">
      ReadMessage
     </a>
     <a class="permalink" href="#Consumer.ReadMessage">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) ReadMessage(timeout <a href="//golang.org/pkg/time/">time</a>.<a href="//golang.org/pkg/time/#Duration">Duration</a>) (*<a href="#Message">Message</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     ReadMessage polls the consumer for a message.
    </p>
    <p>
     This is a conveniance API that wraps Poll() and only returns
messages or errors. All other event types are discarded.
    </p>
    <p>
     The call will block for at most `timeout` waiting for
a new message or error. `timeout` may be set to -1 for
indefinite wait.
    </p>
    <p>
     Timeout is returned as (nil, err) where err is `kafka.(Error).Code == Kafka.ErrTimedOut`.
    </p>
    <p>
     Messages are returned as (msg, nil),
while general errors are returned as (nil, err),
and partition-specific errors are returned as (msg, err) where
msg.TopicPartition provides partition-specific information (such as topic, partition and offset).
    </p>
    <p>
     All other event types, such as PartitionEOF, AssignedPartitions, etc, are silently discarded.
    </p>
    <h3 id="Consumer.Resume">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=18454:18520#L570">
      Resume
     </a>
     <a class="permalink" href="#Consumer.Resume">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Resume(partitions []<a href="#TopicPartition">TopicPartition</a>) (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Resume consumption for the provided list of partitions
    </p>
    <h3 id="Consumer.Seek">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=7391:7461#L226">
      Seek
     </a>
     <a class="permalink" href="#Consumer.Seek">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Seek(partition <a href="#TopicPartition">TopicPartition</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     Seek seeks the given topic partitions using the offset from the TopicPartition.
    </p>
    <p>
     If timeoutMs is not 0 the call will wait this long for the
seek to be performed. If the timeout is reached the internal state
will be unknown and this function returns ErrTimedOut.
If timeoutMs is 0 it will initiate the seek but return
immediately without any error reporting (e.g., async).
    </p>
    <p>
     Seek() may only be used for partitions already being consumed
(through Assign() or implicitly through a self-rebalanced Subscribe()).
To set the starting offset it is preferred to use Assign() and provide
a starting offset for each partition.
    </p>
    <p>
     Returns an error on failure or nil otherwise.
    </p>
    <h3 id="Consumer.SetOAuthBearerToken">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=19370:19449#L590">
      SetOAuthBearerToken
     </a>
     <a class="permalink" href="#Consumer.SetOAuthBearerToken">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) SetOAuthBearerToken(oauthBearerToken <a href="#OAuthBearerToken">OAuthBearerToken</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetOAuthBearerToken sets the the data to be transmitted
to a broker during SASL/OAUTHBEARER authentication. It will return nil
on success, otherwise an error if:
1) the token data is invalid (meaning an expiration time in the past
or either a token value or an extension key or value that does not meet
the regular expression requirements as per
     <a href="https://tools.ietf.org/html/rfc7628#section-3.1">
      https://tools.ietf.org/html/rfc7628#section-3.1
     </a>
     );
2) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;
3) SASL/OAUTHBEARER is supported but is not configured as the client's
authentication mechanism.
    </p>
    <h3 id="Consumer.SetOAuthBearerTokenFailure">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=19948:20014#L601">
      SetOAuthBearerTokenFailure
     </a>
     <a class="permalink" href="#Consumer.SetOAuthBearerTokenFailure">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) SetOAuthBearerTokenFailure(errstr <a href="//golang.org/pkg/builtin/#string">string</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetOAuthBearerTokenFailure sets the error message describing why token
retrieval/setting failed; it also schedules a new token refresh event for 10
seconds later so the attempt may be retried. It will return nil on
success, otherwise an error if:
1) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;
2) SASL/OAUTHBEARER is supported but is not configured as the client's
authentication mechanism.
    </p>
    <h3 id="Consumer.StoreOffsets">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=6199:6300#L196">
      StoreOffsets
     </a>
     <a class="permalink" href="#Consumer.StoreOffsets">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) StoreOffsets(offsets []<a href="#TopicPartition">TopicPartition</a>) (storedOffsets []<a href="#TopicPartition">TopicPartition</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     StoreOffsets stores the provided list of offsets that will be committed
to the offset store according to `auto.commit.interval.ms` or manual
offset-less Commit().
    </p>
    <p>
     Returns the stored offsets on success. If at least one offset couldn't be stored,
an error and a list of offsets is returned. Each offset can be checked for
specific errors via its `.Error` member.
    </p>
    <h3 id="Consumer.String">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=1487:1521#L43">
      String
     </a>
     <a class="permalink" href="#Consumer.String">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     Strings returns a human readable name for a Consumer instance
    </p>
    <h3 id="Consumer.Subscribe">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=1733:1806#L54">
      Subscribe
     </a>
     <a class="permalink" href="#Consumer.Subscribe">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Subscribe(topic <a href="//golang.org/pkg/builtin/#string">string</a>, rebalanceCb <a href="#RebalanceCb">RebalanceCb</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     Subscribe to a single topic
This replaces the current subscription
    </p>
    <h3 id="Consumer.SubscribeTopics">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=1973:2061#L60">
      SubscribeTopics
     </a>
     <a class="permalink" href="#Consumer.SubscribeTopics">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) SubscribeTopics(topics []<a href="//golang.org/pkg/builtin/#string">string</a>, rebalanceCb <a href="#RebalanceCb">RebalanceCb</a>) (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     SubscribeTopics subscribes to the provided list of topics.
This replaces the current subscription.
    </p>
    <h3 id="Consumer.Subscription">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=16346:16408#L507">
      Subscription
     </a>
     <a class="permalink" href="#Consumer.Subscription">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Subscription() (topics []<a href="//golang.org/pkg/builtin/#string">string</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Subscription returns the current subscription as set by Subscribe()
    </p>
    <h3 id="Consumer.Unassign">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=3237:3278#L104">
      Unassign
     </a>
     <a class="permalink" href="#Consumer.Unassign">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Unassign() (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Unassign the current set of partitions to consume.
    </p>
    <h3 id="Consumer.Unsubscribe">
     func (*Consumer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=2666:2710#L82">
      Unsubscribe
     </a>
     <a class="permalink" href="#Consumer.Unsubscribe">
      ¶
     </a>
    </h3>
    <pre>func (c *<a href="#Consumer">Consumer</a>) Unsubscribe() (err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     Unsubscribe from the current subscription, if any.
    </p>
    <h2 id="CreatePartitionsAdminOption">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=6130:6254#L212">
      CreatePartitionsAdminOption
     </a>
     <a class="permalink" href="#CreatePartitionsAdminOption">
      ¶
     </a>
    </h2>
    <p>
     CreatePartitionsAdminOption - see setters.
    </p>
    <p>
     See SetAdminRequestTimeout, SetAdminOperationTimeout, SetAdminValidateOnly.
    </p>
    <pre>type CreatePartitionsAdminOption interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="CreateTopicsAdminOption">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=5664:5780#L196">
      CreateTopicsAdminOption
     </a>
     <a class="permalink" href="#CreateTopicsAdminOption">
      ¶
     </a>
    </h2>
    <p>
     CreateTopicsAdminOption - see setters.
    </p>
    <p>
     See SetAdminRequestTimeout, SetAdminOperationTimeout, SetAdminValidateOnly.
    </p>
    <pre>type CreateTopicsAdminOption interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="DeleteTopicsAdminOption">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=5884:6000#L204">
      DeleteTopicsAdminOption
     </a>
     <a class="permalink" href="#DeleteTopicsAdminOption">
      ¶
     </a>
    </h2>
    <p>
     DeleteTopicsAdminOption - see setters.
    </p>
    <p>
     See SetAdminRequestTimeout, SetAdminOperationTimeout.
    </p>
    <pre>type DeleteTopicsAdminOption interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="DescribeConfigsAdminOption">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminoptions.go?s=6572:6694#L228">
      DescribeConfigsAdminOption
     </a>
     <a class="permalink" href="#DescribeConfigsAdminOption">
      ¶
     </a>
    </h2>
    <p>
     DescribeConfigsAdminOption - see setters.
    </p>
    <p>
     See SetAdminRequestTimeout.
    </p>
    <pre>type DescribeConfigsAdminOption interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="Error">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go?s=911:975#L25">
      Error
     </a>
     <a class="permalink" href="#Error">
      ¶
     </a>
    </h2>
    <p>
     Error provides a Kafka-specific error container
    </p>
    <pre>type Error struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="NewError">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go?s=1111:1176#L36">
      NewError
     </a>
     <a class="permalink" href="#NewError">
      ¶
     </a>
    </h3>
    <pre>func NewError(code <a href="#ErrorCode">ErrorCode</a>, str <a href="//golang.org/pkg/builtin/#string">string</a>, fatal <a href="//golang.org/pkg/builtin/#bool">bool</a>) (err <a href="#Error">Error</a>)</pre>
    <p>
     NewError creates a new Error.
    </p>
    <h3 id="Error.Code">
     func (Error)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go?s=2120:2151#L81">
      Code
     </a>
     <a class="permalink" href="#Error.Code">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#Error">Error</a>) Code() <a href="#ErrorCode">ErrorCode</a></pre>
    <p>
     Code returns the ErrorCode of an Error
    </p>
    <h3 id="Error.Error">
     func (Error)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go?s=1743:1772#L60">
      Error
     </a>
     <a class="permalink" href="#Error.Error">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#Error">Error</a>) Error() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     Error returns a human readable representation of an Error
Same as Error.String()
    </p>
    <h3 id="Error.IsFatal">
     func (Error)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go?s=2395:2424#L89">
      IsFatal
     </a>
     <a class="permalink" href="#Error.IsFatal">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#Error">Error</a>) IsFatal() <a href="//golang.org/pkg/builtin/#bool">bool</a></pre>
    <p>
     IsFatal returns true if the error is a fatal error.
A fatal error indicates the client instance is no longer operable and
should be terminated. Typical causes include non-recoverable
idempotent producer errors.
    </p>
    <h3 id="Error.String">
     func (Error)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/error.go?s=1859:1889#L65">
      String
     </a>
     <a class="permalink" href="#Error.String">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#Error">Error</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human readable representation of an Error
    </p>
    <h2 id="ErrorCode">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/generated_errors.go?s=324:342#L1">
      ErrorCode
     </a>
     <a class="permalink" href="#ErrorCode">
      ¶
     </a>
    </h2>
    <p>
     ErrorCode is the integer representation of local and broker error codes
    </p>
    <pre>type ErrorCode <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <pre>const (
    <span class="comment">// ErrBadMsg Local: Bad message format</span>
    <span id="ErrBadMsg">ErrBadMsg</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__BAD_MSG">RD_KAFKA_RESP_ERR__BAD_MSG</a>)
    <span class="comment">// ErrBadCompression Local: Invalid compressed data</span>
    <span id="ErrBadCompression">ErrBadCompression</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__BAD_COMPRESSION">RD_KAFKA_RESP_ERR__BAD_COMPRESSION</a>)
    <span class="comment">// ErrDestroy Local: Broker handle destroyed</span>
    <span id="ErrDestroy">ErrDestroy</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__DESTROY">RD_KAFKA_RESP_ERR__DESTROY</a>)
    <span class="comment">// ErrFail Local: Communication failure with broker</span>
    <span id="ErrFail">ErrFail</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__FAIL">RD_KAFKA_RESP_ERR__FAIL</a>)
    <span class="comment">// ErrTransport Local: Broker transport failure</span>
    <span id="ErrTransport">ErrTransport</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__TRANSPORT">RD_KAFKA_RESP_ERR__TRANSPORT</a>)
    <span class="comment">// ErrCritSysResource Local: Critical system resource failure</span>
    <span id="ErrCritSysResource">ErrCritSysResource</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</a>)
    <span class="comment">// ErrResolve Local: Host resolution failure</span>
    <span id="ErrResolve">ErrResolve</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__RESOLVE">RD_KAFKA_RESP_ERR__RESOLVE</a>)
    <span class="comment">// ErrMsgTimedOut Local: Message timed out</span>
    <span id="ErrMsgTimedOut">ErrMsgTimedOut</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__MSG_TIMED_OUT">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</a>)
    <span class="comment">// ErrPartitionEOF Broker: No more messages</span>
    <span id="ErrPartitionEOF">ErrPartitionEOF</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__PARTITION_EOF">RD_KAFKA_RESP_ERR__PARTITION_EOF</a>)
    <span class="comment">// ErrUnknownPartition Local: Unknown partition</span>
    <span id="ErrUnknownPartition">ErrUnknownPartition</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</a>)
    <span class="comment">// ErrFs Local: File or filesystem error</span>
    <span id="ErrFs">ErrFs</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__FS">RD_KAFKA_RESP_ERR__FS</a>)
    <span class="comment">// ErrUnknownTopic Local: Unknown topic</span>
    <span id="ErrUnknownTopic">ErrUnknownTopic</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</a>)
    <span class="comment">// ErrAllBrokersDown Local: All broker connections are down</span>
    <span id="ErrAllBrokersDown">ErrAllBrokersDown</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</a>)
    <span class="comment">// ErrInvalidArg Local: Invalid argument or configuration</span>
    <span id="ErrInvalidArg">ErrInvalidArg</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__INVALID_ARG">RD_KAFKA_RESP_ERR__INVALID_ARG</a>)
    <span class="comment">// ErrTimedOut Local: Timed out</span>
    <span id="ErrTimedOut">ErrTimedOut</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__TIMED_OUT">RD_KAFKA_RESP_ERR__TIMED_OUT</a>)
    <span class="comment">// ErrQueueFull Local: Queue full</span>
    <span id="ErrQueueFull">ErrQueueFull</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__QUEUE_FULL">RD_KAFKA_RESP_ERR__QUEUE_FULL</a>)
    <span class="comment">// ErrIsrInsuff Local: ISR count insufficient</span>
    <span id="ErrIsrInsuff">ErrIsrInsuff</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__ISR_INSUFF">RD_KAFKA_RESP_ERR__ISR_INSUFF</a>)
    <span class="comment">// ErrNodeUpdate Local: Broker node update</span>
    <span id="ErrNodeUpdate">ErrNodeUpdate</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__NODE_UPDATE">RD_KAFKA_RESP_ERR__NODE_UPDATE</a>)
    <span class="comment">// ErrSsl Local: SSL error</span>
    <span id="ErrSsl">ErrSsl</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__SSL">RD_KAFKA_RESP_ERR__SSL</a>)
    <span class="comment">// ErrWaitCoord Local: Waiting for coordinator</span>
    <span id="ErrWaitCoord">ErrWaitCoord</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__WAIT_COORD">RD_KAFKA_RESP_ERR__WAIT_COORD</a>)
    <span class="comment">// ErrUnknownGroup Local: Unknown group</span>
    <span id="ErrUnknownGroup">ErrUnknownGroup</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__UNKNOWN_GROUP">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</a>)
    <span class="comment">// ErrInProgress Local: Operation in progress</span>
    <span id="ErrInProgress">ErrInProgress</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__IN_PROGRESS">RD_KAFKA_RESP_ERR__IN_PROGRESS</a>)
    <span class="comment">// ErrPrevInProgress Local: Previous operation in progress</span>
    <span id="ErrPrevInProgress">ErrPrevInProgress</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</a>)
    <span class="comment">// ErrExistingSubscription Local: Existing subscription</span>
    <span id="ErrExistingSubscription">ErrExistingSubscription</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</a>)
    <span class="comment">// ErrAssignPartitions Local: Assign partitions</span>
    <span id="ErrAssignPartitions">ErrAssignPartitions</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</a>)
    <span class="comment">// ErrRevokePartitions Local: Revoke partitions</span>
    <span id="ErrRevokePartitions">ErrRevokePartitions</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</a>)
    <span class="comment">// ErrConflict Local: Conflicting use</span>
    <span id="ErrConflict">ErrConflict</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__CONFLICT">RD_KAFKA_RESP_ERR__CONFLICT</a>)
    <span class="comment">// ErrState Local: Erroneous state</span>
    <span id="ErrState">ErrState</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__STATE">RD_KAFKA_RESP_ERR__STATE</a>)
    <span class="comment">// ErrUnknownProtocol Local: Unknown protocol</span>
    <span id="ErrUnknownProtocol">ErrUnknownProtocol</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</a>)
    <span class="comment">// ErrNotImplemented Local: Not implemented</span>
    <span id="ErrNotImplemented">ErrNotImplemented</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</a>)
    <span class="comment">// ErrAuthentication Local: Authentication failure</span>
    <span id="ErrAuthentication">ErrAuthentication</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__AUTHENTICATION">RD_KAFKA_RESP_ERR__AUTHENTICATION</a>)
    <span class="comment">// ErrNoOffset Local: No offset stored</span>
    <span id="ErrNoOffset">ErrNoOffset</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__NO_OFFSET">RD_KAFKA_RESP_ERR__NO_OFFSET</a>)
    <span class="comment">// ErrOutdated Local: Outdated</span>
    <span id="ErrOutdated">ErrOutdated</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__OUTDATED">RD_KAFKA_RESP_ERR__OUTDATED</a>)
    <span class="comment">// ErrTimedOutQueue Local: Timed out in queue</span>
    <span id="ErrTimedOutQueue">ErrTimedOutQueue</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</a>)
    <span class="comment">// ErrUnsupportedFeature Local: Required feature not supported by broker</span>
    <span id="ErrUnsupportedFeature">ErrUnsupportedFeature</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</a>)
    <span class="comment">// ErrWaitCache Local: Awaiting cache update</span>
    <span id="ErrWaitCache">ErrWaitCache</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__WAIT_CACHE">RD_KAFKA_RESP_ERR__WAIT_CACHE</a>)
    <span class="comment">// ErrIntr Local: Operation interrupted</span>
    <span id="ErrIntr">ErrIntr</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__INTR">RD_KAFKA_RESP_ERR__INTR</a>)
    <span class="comment">// ErrKeySerialization Local: Key serialization error</span>
    <span id="ErrKeySerialization">ErrKeySerialization</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__KEY_SERIALIZATION">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</a>)
    <span class="comment">// ErrValueSerialization Local: Value serialization error</span>
    <span id="ErrValueSerialization">ErrValueSerialization</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</a>)
    <span class="comment">// ErrKeyDeserialization Local: Key deserialization error</span>
    <span id="ErrKeyDeserialization">ErrKeyDeserialization</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</a>)
    <span class="comment">// ErrValueDeserialization Local: Value deserialization error</span>
    <span id="ErrValueDeserialization">ErrValueDeserialization</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</a>)
    <span class="comment">// ErrPartial Local: Partial response</span>
    <span id="ErrPartial">ErrPartial</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__PARTIAL">RD_KAFKA_RESP_ERR__PARTIAL</a>)
    <span class="comment">// ErrReadOnly Local: Read-only object</span>
    <span id="ErrReadOnly">ErrReadOnly</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__READ_ONLY">RD_KAFKA_RESP_ERR__READ_ONLY</a>)
    <span class="comment">// ErrNoent Local: No such entry</span>
    <span id="ErrNoent">ErrNoent</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__NOENT">RD_KAFKA_RESP_ERR__NOENT</a>)
    <span class="comment">// ErrUnderflow Local: Read underflow</span>
    <span id="ErrUnderflow">ErrUnderflow</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__UNDERFLOW">RD_KAFKA_RESP_ERR__UNDERFLOW</a>)
    <span class="comment">// ErrInvalidType Local: Invalid type</span>
    <span id="ErrInvalidType">ErrInvalidType</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__INVALID_TYPE">RD_KAFKA_RESP_ERR__INVALID_TYPE</a>)
    <span class="comment">// ErrRetry Local: Retry operation</span>
    <span id="ErrRetry">ErrRetry</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__RETRY">RD_KAFKA_RESP_ERR__RETRY</a>)
    <span class="comment">// ErrPurgeQueue Local: Purged in queue</span>
    <span id="ErrPurgeQueue">ErrPurgeQueue</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__PURGE_QUEUE">RD_KAFKA_RESP_ERR__PURGE_QUEUE</a>)
    <span class="comment">// ErrPurgeInflight Local: Purged in flight</span>
    <span id="ErrPurgeInflight">ErrPurgeInflight</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__PURGE_INFLIGHT">RD_KAFKA_RESP_ERR__PURGE_INFLIGHT</a>)
    <span class="comment">// ErrFatal Local: Fatal error</span>
    <span id="ErrFatal">ErrFatal</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__FATAL">RD_KAFKA_RESP_ERR__FATAL</a>)
    <span class="comment">// ErrInconsistent Local: Inconsistent state</span>
    <span id="ErrInconsistent">ErrInconsistent</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__INCONSISTENT">RD_KAFKA_RESP_ERR__INCONSISTENT</a>)
    <span class="comment">// ErrGaplessGuarantee Local: Gap-less ordering would not be guaranteed if proceeding</span>
    <span id="ErrGaplessGuarantee">ErrGaplessGuarantee</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE">RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE</a>)
    <span class="comment">// ErrMaxPollExceeded Local: Maximum application poll interval (max.poll.interval.ms) exceeded</span>
    <span id="ErrMaxPollExceeded">ErrMaxPollExceeded</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED">RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED</a>)
    <span class="comment">// ErrUnknown Unknown broker error</span>
    <span id="ErrUnknown">ErrUnknown</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNKNOWN">RD_KAFKA_RESP_ERR_UNKNOWN</a>)
    <span class="comment">// ErrNoError Success</span>
    <span id="ErrNoError">ErrNoError</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NO_ERROR">RD_KAFKA_RESP_ERR_NO_ERROR</a>)
    <span class="comment">// ErrOffsetOutOfRange Broker: Offset out of range</span>
    <span id="ErrOffsetOutOfRange">ErrOffsetOutOfRange</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</a>)
    <span class="comment">// ErrInvalidMsg Broker: Invalid message</span>
    <span id="ErrInvalidMsg">ErrInvalidMsg</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_MSG">RD_KAFKA_RESP_ERR_INVALID_MSG</a>)
    <span class="comment">// ErrUnknownTopicOrPart Broker: Unknown topic or partition</span>
    <span id="ErrUnknownTopicOrPart">ErrUnknownTopicOrPart</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</a>)
    <span class="comment">// ErrInvalidMsgSize Broker: Invalid message size</span>
    <span id="ErrInvalidMsgSize">ErrInvalidMsgSize</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</a>)
    <span class="comment">// ErrLeaderNotAvailable Broker: Leader not available</span>
    <span id="ErrLeaderNotAvailable">ErrLeaderNotAvailable</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</a>)
    <span class="comment">// ErrNotLeaderForPartition Broker: Not leader for partition</span>
    <span id="ErrNotLeaderForPartition">ErrNotLeaderForPartition</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</a>)
    <span class="comment">// ErrRequestTimedOut Broker: Request timed out</span>
    <span id="ErrRequestTimedOut">ErrRequestTimedOut</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</a>)
    <span class="comment">// ErrBrokerNotAvailable Broker: Broker not available</span>
    <span id="ErrBrokerNotAvailable">ErrBrokerNotAvailable</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</a>)
    <span class="comment">// ErrReplicaNotAvailable Broker: Replica not available</span>
    <span id="ErrReplicaNotAvailable">ErrReplicaNotAvailable</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</a>)
    <span class="comment">// ErrMsgSizeTooLarge Broker: Message size too large</span>
    <span id="ErrMsgSizeTooLarge">ErrMsgSizeTooLarge</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</a>)
    <span class="comment">// ErrStaleCtrlEpoch Broker: StaleControllerEpochCode</span>
    <span id="ErrStaleCtrlEpoch">ErrStaleCtrlEpoch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</a>)
    <span class="comment">// ErrOffsetMetadataTooLarge Broker: Offset metadata string too large</span>
    <span id="ErrOffsetMetadataTooLarge">ErrOffsetMetadataTooLarge</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</a>)
    <span class="comment">// ErrNetworkException Broker: Broker disconnected before response received</span>
    <span id="ErrNetworkException">ErrNetworkException</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</a>)
    <span class="comment">// ErrGroupLoadInProgress Broker: Group coordinator load in progress</span>
    <span id="ErrGroupLoadInProgress">ErrGroupLoadInProgress</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</a>)
    <span class="comment">// ErrGroupCoordinatorNotAvailable Broker: Group coordinator not available</span>
    <span id="ErrGroupCoordinatorNotAvailable">ErrGroupCoordinatorNotAvailable</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</a>)
    <span class="comment">// ErrNotCoordinatorForGroup Broker: Not coordinator for group</span>
    <span id="ErrNotCoordinatorForGroup">ErrNotCoordinatorForGroup</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</a>)
    <span class="comment">// ErrTopicException Broker: Invalid topic</span>
    <span id="ErrTopicException">ErrTopicException</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</a>)
    <span class="comment">// ErrRecordListTooLarge Broker: Message batch larger than configured server segment size</span>
    <span id="ErrRecordListTooLarge">ErrRecordListTooLarge</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</a>)
    <span class="comment">// ErrNotEnoughReplicas Broker: Not enough in-sync replicas</span>
    <span id="ErrNotEnoughReplicas">ErrNotEnoughReplicas</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</a>)
    <span class="comment">// ErrNotEnoughReplicasAfterAppend Broker: Message(s) written to insufficient number of in-sync replicas</span>
    <span id="ErrNotEnoughReplicasAfterAppend">ErrNotEnoughReplicasAfterAppend</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</a>)
    <span class="comment">// ErrInvalidRequiredAcks Broker: Invalid required acks value</span>
    <span id="ErrInvalidRequiredAcks">ErrInvalidRequiredAcks</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</a>)
    <span class="comment">// ErrIllegalGeneration Broker: Specified group generation id is not valid</span>
    <span id="ErrIllegalGeneration">ErrIllegalGeneration</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</a>)
    <span class="comment">// ErrInconsistentGroupProtocol Broker: Inconsistent group protocol</span>
    <span id="ErrInconsistentGroupProtocol">ErrInconsistentGroupProtocol</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</a>)
    <span class="comment">// ErrInvalidGroupID Broker: Invalid group.id</span>
    <span id="ErrInvalidGroupID">ErrInvalidGroupID</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_GROUP_ID">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</a>)
    <span class="comment">// ErrUnknownMemberID Broker: Unknown member</span>
    <span id="ErrUnknownMemberID">ErrUnknownMemberID</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</a>)
    <span class="comment">// ErrInvalidSessionTimeout Broker: Invalid session timeout</span>
    <span id="ErrInvalidSessionTimeout">ErrInvalidSessionTimeout</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</a>)
    <span class="comment">// ErrRebalanceInProgress Broker: Group rebalance in progress</span>
    <span id="ErrRebalanceInProgress">ErrRebalanceInProgress</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</a>)
    <span class="comment">// ErrInvalidCommitOffsetSize Broker: Commit offset data size is not valid</span>
    <span id="ErrInvalidCommitOffsetSize">ErrInvalidCommitOffsetSize</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</a>)
    <span class="comment">// ErrTopicAuthorizationFailed Broker: Topic authorization failed</span>
    <span id="ErrTopicAuthorizationFailed">ErrTopicAuthorizationFailed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</a>)
    <span class="comment">// ErrGroupAuthorizationFailed Broker: Group authorization failed</span>
    <span id="ErrGroupAuthorizationFailed">ErrGroupAuthorizationFailed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</a>)
    <span class="comment">// ErrClusterAuthorizationFailed Broker: Cluster authorization failed</span>
    <span id="ErrClusterAuthorizationFailed">ErrClusterAuthorizationFailed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</a>)
    <span class="comment">// ErrInvalidTimestamp Broker: Invalid timestamp</span>
    <span id="ErrInvalidTimestamp">ErrInvalidTimestamp</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</a>)
    <span class="comment">// ErrUnsupportedSaslMechanism Broker: Unsupported SASL mechanism</span>
    <span id="ErrUnsupportedSaslMechanism">ErrUnsupportedSaslMechanism</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</a>)
    <span class="comment">// ErrIllegalSaslState Broker: Request not valid in current SASL state</span>
    <span id="ErrIllegalSaslState">ErrIllegalSaslState</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</a>)
    <span class="comment">// ErrUnsupportedVersion Broker: API version not supported</span>
    <span id="ErrUnsupportedVersion">ErrUnsupportedVersion</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</a>)
    <span class="comment">// ErrTopicAlreadyExists Broker: Topic already exists</span>
    <span id="ErrTopicAlreadyExists">ErrTopicAlreadyExists</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</a>)
    <span class="comment">// ErrInvalidPartitions Broker: Invalid number of partitions</span>
    <span id="ErrInvalidPartitions">ErrInvalidPartitions</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_PARTITIONS">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</a>)
    <span class="comment">// ErrInvalidReplicationFactor Broker: Invalid replication factor</span>
    <span id="ErrInvalidReplicationFactor">ErrInvalidReplicationFactor</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</a>)
    <span class="comment">// ErrInvalidReplicaAssignment Broker: Invalid replica assignment</span>
    <span id="ErrInvalidReplicaAssignment">ErrInvalidReplicaAssignment</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</a>)
    <span class="comment">// ErrInvalidConfig Broker: Configuration is invalid</span>
    <span id="ErrInvalidConfig">ErrInvalidConfig</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_CONFIG">RD_KAFKA_RESP_ERR_INVALID_CONFIG</a>)
    <span class="comment">// ErrNotController Broker: Not controller for cluster</span>
    <span id="ErrNotController">ErrNotController</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NOT_CONTROLLER">RD_KAFKA_RESP_ERR_NOT_CONTROLLER</a>)
    <span class="comment">// ErrInvalidRequest Broker: Invalid request</span>
    <span id="ErrInvalidRequest">ErrInvalidRequest</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_REQUEST">RD_KAFKA_RESP_ERR_INVALID_REQUEST</a>)
    <span class="comment">// ErrUnsupportedForMessageFormat Broker: Message format on broker does not support request</span>
    <span id="ErrUnsupportedForMessageFormat">ErrUnsupportedForMessageFormat</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</a>)
    <span class="comment">// ErrPolicyViolation Broker: Policy violation</span>
    <span id="ErrPolicyViolation">ErrPolicyViolation</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_POLICY_VIOLATION">RD_KAFKA_RESP_ERR_POLICY_VIOLATION</a>)
    <span class="comment">// ErrOutOfOrderSequenceNumber Broker: Broker received an out of order sequence number</span>
    <span id="ErrOutOfOrderSequenceNumber">ErrOutOfOrderSequenceNumber</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</a>)
    <span class="comment">// ErrDuplicateSequenceNumber Broker: Broker received a duplicate sequence number</span>
    <span id="ErrDuplicateSequenceNumber">ErrDuplicateSequenceNumber</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</a>)
    <span class="comment">// ErrInvalidProducerEpoch Broker: Producer attempted an operation with an old epoch</span>
    <span id="ErrInvalidProducerEpoch">ErrInvalidProducerEpoch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</a>)
    <span class="comment">// ErrInvalidTxnState Broker: Producer attempted a transactional operation in an invalid state</span>
    <span id="ErrInvalidTxnState">ErrInvalidTxnState</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_TXN_STATE">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</a>)
    <span class="comment">// ErrInvalidProducerIDMapping Broker: Producer attempted to use a producer id which is not currently assigned to its transactional id</span>
    <span id="ErrInvalidProducerIDMapping">ErrInvalidProducerIDMapping</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</a>)
    <span class="comment">// ErrInvalidTransactionTimeout Broker: Transaction timeout is larger than the maximum value allowed by the broker's max.transaction.timeout.ms</span>
    <span id="ErrInvalidTransactionTimeout">ErrInvalidTransactionTimeout</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</a>)
    <span class="comment">// ErrConcurrentTransactions Broker: Producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing</span>
    <span id="ErrConcurrentTransactions">ErrConcurrentTransactions</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</a>)
    <span class="comment">// ErrTransactionCoordinatorFenced Broker: Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer</span>
    <span id="ErrTransactionCoordinatorFenced">ErrTransactionCoordinatorFenced</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</a>)
    <span class="comment">// ErrTransactionalIDAuthorizationFailed Broker: Transactional Id authorization failed</span>
    <span id="ErrTransactionalIDAuthorizationFailed">ErrTransactionalIDAuthorizationFailed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</a>)
    <span class="comment">// ErrSecurityDisabled Broker: Security features are disabled</span>
    <span id="ErrSecurityDisabled">ErrSecurityDisabled</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_SECURITY_DISABLED">RD_KAFKA_RESP_ERR_SECURITY_DISABLED</a>)
    <span class="comment">// ErrOperationNotAttempted Broker: Operation not attempted</span>
    <span id="ErrOperationNotAttempted">ErrOperationNotAttempted</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</a>)
    <span class="comment">// ErrKafkaStorageError Disk error when trying to access log file on the disk</span>
    <span id="ErrKafkaStorageError">ErrKafkaStorageError</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR">RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR</a>)
    <span class="comment">// ErrLogDirNotFound The user-specified log directory is not found in the broker config</span>
    <span id="ErrLogDirNotFound">ErrLogDirNotFound</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND">RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND</a>)
    <span class="comment">// ErrSaslAuthenticationFailed SASL Authentication failed</span>
    <span id="ErrSaslAuthenticationFailed">ErrSaslAuthenticationFailed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED">RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED</a>)
    <span class="comment">// ErrUnknownProducerID Unknown Producer Id</span>
    <span id="ErrUnknownProducerID">ErrUnknownProducerID</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID">RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID</a>)
    <span class="comment">// ErrReassignmentInProgress Partition reassignment is in progress</span>
    <span id="ErrReassignmentInProgress">ErrReassignmentInProgress</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS">RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS</a>)
    <span class="comment">// ErrDelegationTokenAuthDisabled Delegation Token feature is not enabled</span>
    <span id="ErrDelegationTokenAuthDisabled">ErrDelegationTokenAuthDisabled</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED</a>)
    <span class="comment">// ErrDelegationTokenNotFound Delegation Token is not found on server</span>
    <span id="ErrDelegationTokenNotFound">ErrDelegationTokenNotFound</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND</a>)
    <span class="comment">// ErrDelegationTokenOwnerMismatch Specified Principal is not valid Owner/Renewer</span>
    <span id="ErrDelegationTokenOwnerMismatch">ErrDelegationTokenOwnerMismatch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH</a>)
    <span class="comment">// ErrDelegationTokenRequestNotAllowed Delegation Token requests are not allowed on this connection</span>
    <span id="ErrDelegationTokenRequestNotAllowed">ErrDelegationTokenRequestNotAllowed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED</a>)
    <span class="comment">// ErrDelegationTokenAuthorizationFailed Delegation Token authorization failed</span>
    <span id="ErrDelegationTokenAuthorizationFailed">ErrDelegationTokenAuthorizationFailed</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED</a>)
    <span class="comment">// ErrDelegationTokenExpired Delegation Token is expired</span>
    <span id="ErrDelegationTokenExpired">ErrDelegationTokenExpired</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED</a>)
    <span class="comment">// ErrInvalidPrincipalType Supplied principalType is not supported</span>
    <span id="ErrInvalidPrincipalType">ErrInvalidPrincipalType</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE">RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE</a>)
    <span class="comment">// ErrNonEmptyGroup The group is not empty</span>
    <span id="ErrNonEmptyGroup">ErrNonEmptyGroup</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP">RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP</a>)
    <span class="comment">// ErrGroupIDNotFound The group id does not exist</span>
    <span id="ErrGroupIDNotFound">ErrGroupIDNotFound</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND">RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND</a>)
    <span class="comment">// ErrFetchSessionIDNotFound The fetch session ID was not found</span>
    <span id="ErrFetchSessionIDNotFound">ErrFetchSessionIDNotFound</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND">RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND</a>)
    <span class="comment">// ErrInvalidFetchSessionEpoch The fetch session epoch is invalid</span>
    <span id="ErrInvalidFetchSessionEpoch">ErrInvalidFetchSessionEpoch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH">RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH</a>)
    <span class="comment">// ErrListenerNotFound No matching listener</span>
    <span id="ErrListenerNotFound">ErrListenerNotFound</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND">RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND</a>)
    <span class="comment">// ErrTopicDeletionDisabled Topic deletion is disabled</span>
    <span id="ErrTopicDeletionDisabled">ErrTopicDeletionDisabled</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED">RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED</a>)
    <span class="comment">// ErrFencedLeaderEpoch Leader epoch is older than broker epoch</span>
    <span id="ErrFencedLeaderEpoch">ErrFencedLeaderEpoch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH">RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH</a>)
    <span class="comment">// ErrUnknownLeaderEpoch Leader epoch is newer than broker epoch</span>
    <span id="ErrUnknownLeaderEpoch">ErrUnknownLeaderEpoch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH">RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH</a>)
    <span class="comment">// ErrUnsupportedCompressionType Unsupported compression type</span>
    <span id="ErrUnsupportedCompressionType">ErrUnsupportedCompressionType</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</a>)
    <span class="comment">// ErrStaleBrokerEpoch Broker epoch has changed</span>
    <span id="ErrStaleBrokerEpoch">ErrStaleBrokerEpoch</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH">RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH</a>)
    <span class="comment">// ErrOffsetNotAvailable Leader high watermark is not caught up</span>
    <span id="ErrOffsetNotAvailable">ErrOffsetNotAvailable</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE">RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE</a>)
    <span class="comment">// ErrMemberIDRequired Group member needs a valid member ID</span>
    <span id="ErrMemberIDRequired">ErrMemberIDRequired</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED">RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED</a>)
    <span class="comment">// ErrPreferredLeaderNotAvailable Preferred leader was not available</span>
    <span id="ErrPreferredLeaderNotAvailable">ErrPreferredLeaderNotAvailable</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE">RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE</a>)
    <span class="comment">// ErrGroupMaxSizeReached Consumer group has reached maximum size</span>
    <span id="ErrGroupMaxSizeReached">ErrGroupMaxSizeReached</span> <a href="#ErrorCode">ErrorCode</a> = <a href="#ErrorCode">ErrorCode</a>(<a href="//golang.org/pkg/C/">C</a>.<a href="//golang.org/pkg/C/#RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED">RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED</a>)
)</pre>
    <h3 id="ErrorCode.String">
     func (ErrorCode)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/generated_errors.go?s=411:445#L4">
      String
     </a>
     <a class="permalink" href="#ErrorCode.String">
      ¶
     </a>
    </h3>
    <pre>func (c <a href="#ErrorCode">ErrorCode</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human readable representation of an error code
    </p>
    <h2 id="Event">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2308:2413#L75">
      Event
     </a>
     <a class="permalink" href="#Event">
      ¶
     </a>
    </h2>
    <p>
     Event generic interface
    </p>
    <pre>type Event interface {
    <span class="comment">// String returns a human-readable representation of the event</span>
    String() <a href="//golang.org/pkg/builtin/#string">string</a>
}</pre>
    <h2 id="Handle">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/handle.go?s=1825:3094#L45">
      Handle
     </a>
     <a class="permalink" href="#Handle">
      ¶
     </a>
    </h2>
    <p>
     Handle represents a generic client handle containing common parts for
both Producer and Consumer.
    </p>
    <pre>type Handle interface {
    <span class="comment">// SetOAuthBearerToken sets the the data to be transmitted</span>
    <span class="comment">// to a broker during SASL/OAUTHBEARER authentication. It will return nil</span>
    <span class="comment">// on success, otherwise an error if:</span>
    <span class="comment">// 1) the token data is invalid (meaning an expiration time in the past</span>
    <span class="comment">// or either a token value or an extension key or value that does not meet</span>
    <span class="comment">// the regular expression requirements as per</span>
    <span class="comment">// https://tools.ietf.org/html/rfc7628#section-3.1);</span>
    <span class="comment">// 2) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;</span>
    <span class="comment">// 3) SASL/OAUTHBEARER is supported but is not configured as the client's</span>
    <span class="comment">// authentication mechanism.</span>
    SetOAuthBearerToken(oauthBearerToken <a href="#OAuthBearerToken">OAuthBearerToken</a>) <a href="//golang.org/pkg/builtin/#error">error</a>

    <span class="comment">// SetOAuthBearerTokenFailure sets the error message describing why token</span>
    <span class="comment">// retrieval/setting failed; it also schedules a new token refresh event for 10</span>
    <span class="comment">// seconds later so the attempt may be retried. It will return nil on</span>
    <span class="comment">// success, otherwise an error if:</span>
    <span class="comment">// 1) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;</span>
    <span class="comment">// 2) SASL/OAUTHBEARER is supported but is not configured as the client's</span>
    <span class="comment">// authentication mechanism.</span>
    SetOAuthBearerTokenFailure(errstr <a href="//golang.org/pkg/builtin/#string">string</a>) <a href="//golang.org/pkg/builtin/#error">error</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
    <h2 id="Header">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/header.go?s=1268:1388#L32">
      Header
     </a>
     <a class="permalink" href="#Header">
      ¶
     </a>
    </h2>
    <p>
     Header represents a single Kafka message header.
    </p>
    <p>
     Message headers are made up of a list of Header elements, retaining their original insert
order and allowing for duplicate Keys.
    </p>
    <p>
     Key is a human readable string identifying the header.
Value is the key's binary value, Kafka does not put any restrictions on the format of
of the Value but it should be made relatively compact.
The value may be a byte array, empty, or nil.
    </p>
    <p>
     NOTE: Message headers are not available on producer delivery report messages.
    </p>
    <pre>type Header struct {
<span id="Header.Key"></span>    Key   <a href="//golang.org/pkg/builtin/#string">string</a> <span class="comment">// Header name (utf-8 string)</span>
<span id="Header.Value"></span>    Value []<a href="//golang.org/pkg/builtin/#byte">byte</a> <span class="comment">// Header value (nil, empty, or binary)</span>
}
</pre>
    <h3 id="Header.String">
     func (Header)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/header.go?s=1521:1552#L39">
      String
     </a>
     <a class="permalink" href="#Header.String">
      ¶
     </a>
    </h3>
    <pre>func (h <a href="#Header">Header</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns the Header Key and data in a human representable possibly truncated form
suitable for displaying to the user.
    </p>
    <h2 id="Message">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/message.go?s=2122:2331#L63">
      Message
     </a>
     <a class="permalink" href="#Message">
      ¶
     </a>
    </h2>
    <p>
     Message represents a Kafka message
    </p>
    <pre>type Message struct {
<span id="Message.TopicPartition"></span>    TopicPartition <a href="#TopicPartition">TopicPartition</a>
<span id="Message.Value"></span>    Value          []<a href="//golang.org/pkg/builtin/#byte">byte</a>
<span id="Message.Key"></span>    Key            []<a href="//golang.org/pkg/builtin/#byte">byte</a>
<span id="Message.Timestamp"></span>    Timestamp      <a href="//golang.org/pkg/time/">time</a>.<a href="//golang.org/pkg/time/#Time">Time</a>
<span id="Message.TimestampType"></span>    TimestampType  <a href="#TimestampType">TimestampType</a>
<span id="Message.Opaque"></span>    Opaque         interface{}
<span id="Message.Headers"></span>    Headers        []<a href="#Header">Header</a>
}
</pre>
    <h3 id="Message.String">
     func (*Message)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/message.go?s=2437:2470#L75">
      String
     </a>
     <a class="permalink" href="#Message.String">
      ¶
     </a>
    </h3>
    <pre>func (m *<a href="#Message">Message</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human readable representation of a Message.
Key and payload are not represented.
    </p>
    <h2 id="Metadata">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/metadata.go?s=1723:1842#L60">
      Metadata
     </a>
     <a class="permalink" href="#Metadata">
      ¶
     </a>
    </h2>
    <p>
     Metadata contains broker and topic metadata for all (matching) topics
    </p>
    <pre>type Metadata struct {
<span id="Metadata.Brokers"></span>    Brokers []<a href="#BrokerMetadata">BrokerMetadata</a>
<span id="Metadata.Topics"></span>    Topics  map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="#TopicMetadata">TopicMetadata</a>

<span id="Metadata.OriginatingBroker"></span>    OriginatingBroker <a href="#BrokerMetadata">BrokerMetadata</a>
}
</pre>
    <h2 id="OAuthBearerToken">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/handle.go?s=839:1719#L24">
      OAuthBearerToken
     </a>
     <a class="permalink" href="#OAuthBearerToken">
      ¶
     </a>
    </h2>
    <p>
     OAuthBearerToken represents the data to be transmitted
to a broker during SASL/OAUTHBEARER authentication.
    </p>
    <pre>type OAuthBearerToken struct {
    <span class="comment">// Token value, often (but not necessarily) a JWS compact serialization</span>
    <span class="comment">// as per https://tools.ietf.org/html/rfc7515#section-3.1; it must meet</span>
    <span class="comment">// the regular expression for a SASL/OAUTHBEARER value defined at</span>
    <span class="comment">// https://tools.ietf.org/html/rfc7628#section-3.1</span>
<span id="OAuthBearerToken.TokenValue"></span>    TokenValue <a href="//golang.org/pkg/builtin/#string">string</a>
    <span class="comment">// Metadata about the token indicating when it expires (local time);</span>
    <span class="comment">// it must represent a time in the future</span>
<span id="OAuthBearerToken.Expiration"></span>    Expiration <a href="//golang.org/pkg/time/">time</a>.<a href="//golang.org/pkg/time/#Time">Time</a>
    <span class="comment">// Metadata about the token indicating the Kafka principal name</span>
    <span class="comment">// to which it applies (for example, "admin")</span>
<span id="OAuthBearerToken.Principal"></span>    Principal <a href="//golang.org/pkg/builtin/#string">string</a>
    <span class="comment">// SASL extensions, if any, to be communicated to the broker during</span>
    <span class="comment">// authentication (all keys and values of which must meet the regular</span>
    <span class="comment">// expressions defined at https://tools.ietf.org/html/rfc7628#section-3.1,</span>
    <span class="comment">// and it must not contain the reserved "auth" key)</span>
<span id="OAuthBearerToken.Extensions"></span>    Extensions map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="//golang.org/pkg/builtin/#string">string</a>
}
</pre>
    <h2 id="OAuthBearerTokenRefresh">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=3646:3764#L129">
      OAuthBearerTokenRefresh
     </a>
     <a class="permalink" href="#OAuthBearerTokenRefresh">
      ¶
     </a>
    </h2>
    <p>
     OAuthBearerTokenRefresh indicates token refresh is required
    </p>
    <pre>type OAuthBearerTokenRefresh struct {
<span id="OAuthBearerTokenRefresh.Config"></span>    <span class="comment">// Config is the value of the sasl.oauthbearer.config property</span>
    Config <a href="//golang.org/pkg/builtin/#string">string</a>
}
</pre>
    <h3 id="OAuthBearerTokenRefresh.String">
     func (OAuthBearerTokenRefresh)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=3766:3814#L134">
      String
     </a>
     <a class="permalink" href="#OAuthBearerTokenRefresh.String">
      ¶
     </a>
    </h3>
    <pre>func (o <a href="#OAuthBearerTokenRefresh">OAuthBearerTokenRefresh</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="Offset">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/offset.go?s=860:877#L25">
      Offset
     </a>
     <a class="permalink" href="#Offset">
      ¶
     </a>
    </h2>
    <p>
     Offset type (int64) with support for canonical names
    </p>
    <pre>type Offset <a href="//golang.org/pkg/builtin/#int64">int64</a></pre>
    <h3 id="NewOffset">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/offset.go?s=1924:1974#L68">
      NewOffset
     </a>
     <a class="permalink" href="#NewOffset">
      ¶
     </a>
    </h3>
    <pre>func NewOffset(offset interface{}) (<a href="#Offset">Offset</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     NewOffset creates a new Offset using the provided logical string, or an
absolute int64 offset value.
Logical offsets: "beginning", "earliest", "end", "latest", "unset", "invalid", "stored"
    </p>
    <h3 id="OffsetTail">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/offset.go?s=2710:2755#L107">
      OffsetTail
     </a>
     <a class="permalink" href="#OffsetTail">
      ¶
     </a>
    </h3>
    <pre>func OffsetTail(relativeOffset <a href="#Offset">Offset</a>) <a href="#Offset">Offset</a></pre>
    <p>
     OffsetTail returns the logical offset relativeOffset from current end of partition
    </p>
    <h3 id="Offset.Set">
     func (*Offset)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/offset.go?s=1602:1648#L55">
      Set
     </a>
     <a class="permalink" href="#Offset.Set">
      ¶
     </a>
    </h3>
    <pre>func (o *<a href="#Offset">Offset</a>) Set(offset interface{}) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     Set offset value, see NewOffset()
    </p>
    <h3 id="Offset.String">
     func (Offset)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/offset.go?s=1314:1345#L39">
      String
     </a>
     <a class="permalink" href="#Offset.String">
      ¶
     </a>
    </h3>
    <pre>func (o <a href="#Offset">Offset</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="OffsetsCommitted">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=3392:3465#L119">
      OffsetsCommitted
     </a>
     <a class="permalink" href="#OffsetsCommitted">
      ¶
     </a>
    </h2>
    <p>
     OffsetsCommitted reports committed offsets
    </p>
    <pre>type OffsetsCommitted struct {
<span id="OffsetsCommitted.Error"></span>    Error   <a href="//golang.org/pkg/builtin/#error">error</a>
<span id="OffsetsCommitted.Offsets"></span>    Offsets []<a href="#TopicPartition">TopicPartition</a>
}
</pre>
    <h3 id="OffsetsCommitted.String">
     func (OffsetsCommitted)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=3467:3508#L124">
      String
     </a>
     <a class="permalink" href="#OffsetsCommitted.String">
      ¶
     </a>
    </h3>
    <pre>func (o <a href="#OffsetsCommitted">OffsetsCommitted</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="PartitionEOF">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=3217:3249#L112">
      PartitionEOF
     </a>
     <a class="permalink" href="#PartitionEOF">
      ¶
     </a>
    </h2>
    <p>
     PartitionEOF consumer reached end of partition
Needs to be explicitly enabled by setting the `enable.partition.eof`
configuration property to true.
    </p>
    <pre>type PartitionEOF <a href="#TopicPartition">TopicPartition</a></pre>
    <h3 id="PartitionEOF.String">
     func (PartitionEOF)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=3251:3288#L114">
      String
     </a>
     <a class="permalink" href="#PartitionEOF.String">
      ¶
     </a>
    </h3>
    <pre>func (p <a href="#PartitionEOF">PartitionEOF</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="PartitionMetadata">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/metadata.go?s=1386:1503#L44">
      PartitionMetadata
     </a>
     <a class="permalink" href="#PartitionMetadata">
      ¶
     </a>
    </h2>
    <p>
     PartitionMetadata contains per-partition metadata
    </p>
    <pre>type PartitionMetadata struct {
<span id="PartitionMetadata.ID"></span>    ID       <a href="//golang.org/pkg/builtin/#int32">int32</a>
<span id="PartitionMetadata.Error"></span>    Error    <a href="#Error">Error</a>
<span id="PartitionMetadata.Leader"></span>    Leader   <a href="//golang.org/pkg/builtin/#int32">int32</a>
<span id="PartitionMetadata.Replicas"></span>    Replicas []<a href="//golang.org/pkg/builtin/#int32">int32</a>
<span id="PartitionMetadata.Isrs"></span>    Isrs     []<a href="//golang.org/pkg/builtin/#int32">int32</a>
}
</pre>
    <h2 id="PartitionsSpecification">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=2938:3452#L94">
      PartitionsSpecification
     </a>
     <a class="permalink" href="#PartitionsSpecification">
      ¶
     </a>
    </h2>
    <p>
     PartitionsSpecification holds parameters for creating additional partitions for a topic.
PartitionsSpecification is analogous to NewPartitions in the Java Topic Admin API.
    </p>
    <pre>type PartitionsSpecification struct {
<span id="PartitionsSpecification.Topic"></span>    <span class="comment">// Topic to create more partitions for.</span>
    Topic <a href="//golang.org/pkg/builtin/#string">string</a>
    <span class="comment">// New partition count for topic, must be higher than current partition count.</span>
<span id="PartitionsSpecification.IncreaseTo"></span>    IncreaseTo <a href="//golang.org/pkg/builtin/#int">int</a>
    <span class="comment">// (Optional) Explicit replica assignment. The outer array is</span>
    <span class="comment">// indexed by the new partition index (i.e., 0 for the first added</span>
    <span class="comment">// partition), while the inner per-partition array</span>
    <span class="comment">// contains the replica broker ids. The first broker in each</span>
    <span class="comment">// broker id list will be the preferred replica.</span>
<span id="PartitionsSpecification.ReplicaAssignment"></span>    ReplicaAssignment [][]<a href="//golang.org/pkg/builtin/#int32">int32</a>
}
</pre>
    <h2 id="Producer">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=3602:3771#L121">
      Producer
     </a>
     <a class="permalink" href="#Producer">
      ¶
     </a>
    </h2>
    <p>
     Producer implements a High-level Apache Kafka Producer instance
    </p>
    <pre>type Producer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="NewProducer">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=11451:11503#L370">
      NewProducer
     </a>
     <a class="permalink" href="#NewProducer">
      ¶
     </a>
    </h3>
    <pre>func NewProducer(conf *<a href="#ConfigMap">ConfigMap</a>) (*<a href="#Producer">Producer</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     NewProducer creates a new high-level Producer instance.
    </p>
    <p>
     conf is a *ConfigMap with standard librdkafka configuration properties, see here:
    </p>
    <p>
     Supported special configuration properties:
    </p>
    <pre>go.batch.producer (bool, false) - EXPERIMENTAL: Enable batch producer (for increased performance).
                                  These batches do not relate to Kafka message batches in any way.
                                  Note: timestamps and headers are not supported with this interface.
go.delivery.reports (bool, true) - Forward per-message delivery reports to the
                                   Events() channel.
go.events.channel.size (int, 1000000) - Events() channel size
go.produce.channel.size (int, 1000000) - ProduceChannel() buffer size (in number of messages)
</pre>
    <h3 id="Producer.Close">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=10310:10336#L339">
      Close
     </a>
     <a class="permalink" href="#Producer.Close">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) Close()</pre>
    <p>
     Close a Producer instance.
The Producer object or its channels are no longer usable after this call.
    </p>
    <h3 id="Producer.Events">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=9062:9100#L299">
      Events
     </a>
     <a class="permalink" href="#Producer.Events">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) Events() chan <a href="#Event">Event</a></pre>
    <p>
     Events returns the Events channel (read)
    </p>
    <h3 id="Producer.Flush">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=9806:9849#L319">
      Flush
     </a>
     <a class="permalink" href="#Producer.Flush">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) Flush(timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <p>
     Flush and wait for outstanding messages and requests to complete delivery.
Includes messages on ProduceChannel.
Runs until value reaches zero or on timeoutMs.
Returns the number of outstanding events still un-flushed.
    </p>
    <h3 id="Producer.GetFatalError">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=17549:17589#L584">
      GetFatalError
     </a>
     <a class="permalink" href="#Producer.GetFatalError">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) GetFatalError() <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     GetFatalError returns an Error object if the client instance has raised a fatal error, else nil.
    </p>
    <h3 id="Producer.GetMetadata">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=16244:16339#L555">
      GetMetadata
     </a>
     <a class="permalink" href="#Producer.GetMetadata">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) GetMetadata(topic *<a href="//golang.org/pkg/builtin/#string">string</a>, allTopics <a href="//golang.org/pkg/builtin/#bool">bool</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (*<a href="#Metadata">Metadata</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     GetMetadata queries broker for cluster and topic metadata.
If topic is non-nil only information about that topic is returned, else if
allTopics is false only information about locally used topics is returned,
else information about all topics is returned.
GetMetadata is equivalent to listTopics, describeTopics and describeCluster in the Java API.
    </p>
    <h3 id="Producer.Len">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=9456:9484#L311">
      Len
     </a>
     <a class="permalink" href="#Producer.Len">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) Len() <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <p>
     Len returns the number of messages and requests waiting to be transmitted to the broker
as well as delivery reports queued for the application.
Includes messages on ProduceChannel.
    </p>
    <h3 id="Producer.OffsetsForTimes">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=17287:17398#L579">
      OffsetsForTimes
     </a>
     <a class="permalink" href="#Producer.OffsetsForTimes">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) OffsetsForTimes(times []<a href="#TopicPartition">TopicPartition</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (offsets []<a href="#TopicPartition">TopicPartition</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     OffsetsForTimes looks up offsets by timestamp for the given partitions.
    </p>
    <p>
     The returned offset for each partition is the earliest offset whose
timestamp is greater than or equal to the given timestamp in the
corresponding partition.
    </p>
    <p>
     The timestamps to query are represented as `.Offset` in the `times`
argument and the looked up offsets are represented as `.Offset` in the returned
`offsets` list.
    </p>
    <p>
     The function will block for at most timeoutMs milliseconds.
    </p>
    <p>
     Duplicate Topic+Partitions are not supported.
Per-partition errors may be returned in the `.Error` field.
    </p>
    <h3 id="Producer.Produce">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=8158:8229#L273">
      Produce
     </a>
     <a class="permalink" href="#Producer.Produce">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) Produce(msg *<a href="#Message">Message</a>, deliveryChan chan <a href="#Event">Event</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     Produce single message.
This is an asynchronous call that enqueues the message on the internal
transmit queue, thus returning immediately.
The delivery report will be sent on the provided deliveryChan if specified,
or on the Producer object's Events() channel if not.
msg.Timestamp requires librdkafka &gt;= 0.9.4 (else returns ErrNotImplemented),
api.version.request=true, and broker &gt;= 0.10.0.0.
msg.Headers requires librdkafka &gt;= 0.11.4 (else returns ErrNotImplemented),
api.version.request=true, and broker &gt;= 0.11.0.0.
Returns an error if message could not be enqueued.
    </p>
    <h3 id="Producer.ProduceChannel">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=9186:9235#L304">
      ProduceChannel
     </a>
     <a class="permalink" href="#Producer.ProduceChannel">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) ProduceChannel() chan *<a href="#Message">Message</a></pre>
    <p>
     ProduceChannel returns the produce *Message channel (write)
    </p>
    <h3 id="Producer.QueryWatermarkOffsets">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=16502:16617#L561">
      QueryWatermarkOffsets
     </a>
     <a class="permalink" href="#Producer.QueryWatermarkOffsets">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) QueryWatermarkOffsets(topic <a href="//golang.org/pkg/builtin/#string">string</a>, partition <a href="//golang.org/pkg/builtin/#int32">int32</a>, timeoutMs <a href="//golang.org/pkg/builtin/#int">int</a>) (low, high <a href="//golang.org/pkg/builtin/#int64">int64</a>, err <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     QueryWatermarkOffsets returns the broker's low and high offsets for the given topic
and partition.
    </p>
    <h3 id="Producer.SetOAuthBearerToken">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=18450:18529#L604">
      SetOAuthBearerToken
     </a>
     <a class="permalink" href="#Producer.SetOAuthBearerToken">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) SetOAuthBearerToken(oauthBearerToken <a href="#OAuthBearerToken">OAuthBearerToken</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetOAuthBearerToken sets the the data to be transmitted
to a broker during SASL/OAUTHBEARER authentication. It will return nil
on success, otherwise an error if:
1) the token data is invalid (meaning an expiration time in the past
or either a token value or an extension key or value that does not meet
the regular expression requirements as per
     <a href="https://tools.ietf.org/html/rfc7628#section-3.1">
      https://tools.ietf.org/html/rfc7628#section-3.1
     </a>
     );
2) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;
3) SASL/OAUTHBEARER is supported but is not configured as the client's
authentication mechanism.
    </p>
    <h3 id="Producer.SetOAuthBearerTokenFailure">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=19028:19094#L615">
      SetOAuthBearerTokenFailure
     </a>
     <a class="permalink" href="#Producer.SetOAuthBearerTokenFailure">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) SetOAuthBearerTokenFailure(errstr <a href="//golang.org/pkg/builtin/#string">string</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <p>
     SetOAuthBearerTokenFailure sets the error message describing why token
retrieval/setting failed; it also schedules a new token refresh event for 10
seconds later so the attempt may be retried. It will return nil on
success, otherwise an error if:
1) SASL/OAUTHBEARER is not supported by the underlying librdkafka build;
2) SASL/OAUTHBEARER is supported but is not configured as the client's
authentication mechanism.
    </p>
    <h3 id="Producer.String">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=3837:3871#L131">
      String
     </a>
     <a class="permalink" href="#Producer.String">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human readable name for a Producer instance
    </p>
    <h3 id="Producer.TestFatalError">
     func (*Producer)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/producer.go?s=17740:17811#L590">
      TestFatalError
     </a>
     <a class="permalink" href="#Producer.TestFatalError">
      ¶
     </a>
    </h3>
    <pre>func (p *<a href="#Producer">Producer</a>) TestFatalError(code <a href="#ErrorCode">ErrorCode</a>, str <a href="//golang.org/pkg/builtin/#string">string</a>) <a href="#ErrorCode">ErrorCode</a></pre>
    <p>
     TestFatalError triggers a fatal error in the underlying client.
This is to be used strictly for testing purposes.
    </p>
    <h2 id="RebalanceCb">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/consumer.go?s=1069:1114#L29">
      RebalanceCb
     </a>
     <a class="permalink" href="#RebalanceCb">
      ¶
     </a>
    </h2>
    <p>
     RebalanceCb provides a per-Subscribe*() rebalance event callback.
The passed Event will be either AssignedPartitions or RevokedPartitions
    </p>
    <pre>type RebalanceCb func(*<a href="#Consumer">Consumer</a>, <a href="#Event">Event</a>) <a href="//golang.org/pkg/builtin/#error">error</a></pre>
    <h2 id="ResourceType">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=3511:3532#L108">
      ResourceType
     </a>
     <a class="permalink" href="#ResourceType">
      ¶
     </a>
    </h2>
    <p>
     ResourceType represents an Apache Kafka resource type
    </p>
    <pre>type ResourceType <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <h3 id="ResourceTypeFromString">
     func
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=4287:4355#L130">
      ResourceTypeFromString
     </a>
     <a class="permalink" href="#ResourceTypeFromString">
      ¶
     </a>
    </h3>
    <pre>func ResourceTypeFromString(typeString <a href="//golang.org/pkg/builtin/#string">string</a>) (<a href="#ResourceType">ResourceType</a>, <a href="//golang.org/pkg/builtin/#error">error</a>)</pre>
    <p>
     ResourceTypeFromString translates a resource type name/string to
a ResourceType value.
    </p>
    <h3 id="ResourceType.String">
     func (ResourceType)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=4072:4109#L124">
      String
     </a>
     <a class="permalink" href="#ResourceType.String">
      ¶
     </a>
    </h3>
    <pre>func (t <a href="#ResourceType">ResourceType</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns the human-readable representation of a ResourceType
    </p>
    <h2 id="RevokedPartitions">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2889:2951#L101">
      RevokedPartitions
     </a>
     <a class="permalink" href="#RevokedPartitions">
      ¶
     </a>
    </h2>
    <p>
     RevokedPartitions consumer group rebalance event: revoked partition set
    </p>
    <pre>type RevokedPartitions struct {
<span id="RevokedPartitions.Partitions"></span>    Partitions []<a href="#TopicPartition">TopicPartition</a>
}
</pre>
    <h3 id="RevokedPartitions.String">
     func (RevokedPartitions)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2953:2995#L105">
      String
     </a>
     <a class="permalink" href="#RevokedPartitions.String">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#RevokedPartitions">RevokedPartitions</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="Stats">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2466:2505#L83">
      Stats
     </a>
     <a class="permalink" href="#Stats">
      ¶
     </a>
    </h2>
    <p>
     Stats statistics event
    </p>
    <pre>type Stats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>
    <h3 id="Stats.String">
     func (Stats)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/event.go?s=2507:2537#L87">
      String
     </a>
     <a class="permalink" href="#Stats.String">
      ¶
     </a>
    </h3>
    <pre>func (e <a href="#Stats">Stats</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="TimestampType">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/message.go?s=1328:1350#L38">
      TimestampType
     </a>
     <a class="permalink" href="#TimestampType">
      ¶
     </a>
    </h2>
    <p>
     TimestampType is a the Message timestamp type or source
    </p>
    <pre>type TimestampType <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <h3 id="TimestampType.String">
     func (TimestampType)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/message.go?s=1844:1882#L49">
      String
     </a>
     <a class="permalink" href="#TimestampType.String">
      ¶
     </a>
    </h3>
    <pre>func (t <a href="#TimestampType">TimestampType</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="TopicMetadata">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/metadata.go?s=1550:1648#L53">
      TopicMetadata
     </a>
     <a class="permalink" href="#TopicMetadata">
      ¶
     </a>
    </h2>
    <p>
     TopicMetadata contains per-topic metadata
    </p>
    <pre>type TopicMetadata struct {
<span id="TopicMetadata.Topic"></span>    Topic      <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="TopicMetadata.Partitions"></span>    Partitions []<a href="#PartitionMetadata">PartitionMetadata</a>
<span id="TopicMetadata.Error"></span>    Error      <a href="#Error">Error</a>
}
</pre>
    <h2 id="TopicPartition">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=7047:7167#L156">
      TopicPartition
     </a>
     <a class="permalink" href="#TopicPartition">
      ¶
     </a>
    </h2>
    <p>
     TopicPartition is a generic placeholder for a Topic+Partition and optionally Offset.
    </p>
    <pre>type TopicPartition struct {
<span id="TopicPartition.Topic"></span>    Topic     *<a href="//golang.org/pkg/builtin/#string">string</a>
<span id="TopicPartition.Partition"></span>    Partition <a href="//golang.org/pkg/builtin/#int32">int32</a>
<span id="TopicPartition.Offset"></span>    Offset    <a href="#Offset">Offset</a>
<span id="TopicPartition.Metadata"></span>    Metadata  *<a href="//golang.org/pkg/builtin/#string">string</a>
<span id="TopicPartition.Error"></span>    Error     <a href="//golang.org/pkg/builtin/#error">error</a>
}
</pre>
    <h3 id="TopicPartition.String">
     func (TopicPartition)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=7169:7208#L164">
      String
     </a>
     <a class="permalink" href="#TopicPartition.String">
      ¶
     </a>
    </h3>
    <pre>func (p <a href="#TopicPartition">TopicPartition</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <h2 id="TopicPartitions">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=7537:7574#L179">
      TopicPartitions
     </a>
     <a class="permalink" href="#TopicPartitions">
      ¶
     </a>
    </h2>
    <p>
     TopicPartitions is a slice of TopicPartitions that also implements
the sort interface
    </p>
    <pre>type TopicPartitions []<a href="#TopicPartition">TopicPartition</a></pre>
    <h3 id="TopicPartitions.Len">
     func (TopicPartitions)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=7576:7612#L181">
      Len
     </a>
     <a class="permalink" href="#TopicPartitions.Len">
      ¶
     </a>
    </h3>
    <pre>func (tps <a href="#TopicPartitions">TopicPartitions</a>) Len() <a href="//golang.org/pkg/builtin/#int">int</a></pre>
    <h3 id="TopicPartitions.Less">
     func (TopicPartitions)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=7635:7681#L185">
      Less
     </a>
     <a class="permalink" href="#TopicPartitions.Less">
      ¶
     </a>
    </h3>
    <pre>func (tps <a href="#TopicPartitions">TopicPartitions</a>) Less(i, j <a href="//golang.org/pkg/builtin/#int">int</a>) <a href="//golang.org/pkg/builtin/#bool">bool</a></pre>
    <h3 id="TopicPartitions.Swap">
     func (TopicPartitions)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/kafka.go?s=7842:7883#L194">
      Swap
     </a>
     <a class="permalink" href="#TopicPartitions.Swap">
      ¶
     </a>
    </h3>
    <pre>func (tps <a href="#TopicPartitions">TopicPartitions</a>) Swap(i, j <a href="//golang.org/pkg/builtin/#int">int</a>)</pre>
    <h2 id="TopicResult">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=1677:1817#L58">
      TopicResult
     </a>
     <a class="permalink" href="#TopicResult">
      ¶
     </a>
    </h2>
    <p>
     TopicResult provides per-topic operation result (error) information.
    </p>
    <pre>type TopicResult struct {
<span id="TopicResult.Topic"></span>    <span class="comment">// Topic name</span>
    Topic <a href="//golang.org/pkg/builtin/#string">string</a>
<span id="TopicResult.Error"></span>    <span class="comment">// Error, if any, of result. Check with `Error.Code() != ErrNoError`.</span>
    Error <a href="#Error">Error</a>
}
</pre>
    <h3 id="TopicResult.String">
     func (TopicResult)
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=1887:1923#L66">
      String
     </a>
     <a class="permalink" href="#TopicResult.String">
      ¶
     </a>
    </h3>
    <pre>func (t <a href="#TopicResult">TopicResult</a>) String() <a href="//golang.org/pkg/builtin/#string">string</a></pre>
    <p>
     String returns a human-readable representation of a TopicResult.
    </p>
    <h2 id="TopicSpecification">
     type
     <a href="//golang.org/src/github.com/confluentinc/confluent-kafka-go/kafka/adminapi.go?s=2167:2758#L75">
      TopicSpecification
     </a>
     <a class="permalink" href="#TopicSpecification">
      ¶
     </a>
    </h2>
    <p>
     TopicSpecification holds parameters for creating a new topic.
TopicSpecification is analogous to NewTopic in the Java Topic Admin API.
    </p>
    <pre>type TopicSpecification struct {
<span id="TopicSpecification.Topic"></span>    <span class="comment">// Topic name to create.</span>
    Topic <a href="//golang.org/pkg/builtin/#string">string</a>
    <span class="comment">// Number of partitions in topic.</span>
<span id="TopicSpecification.NumPartitions"></span>    NumPartitions <a href="//golang.org/pkg/builtin/#int">int</a>
    <span class="comment">// Default replication factor for the topic's partitions, or zero</span>
    <span class="comment">// if an explicit ReplicaAssignment is set.</span>
<span id="TopicSpecification.ReplicationFactor"></span>    ReplicationFactor <a href="//golang.org/pkg/builtin/#int">int</a>
    <span class="comment">// (Optional) Explicit replica assignment. The outer array is</span>
    <span class="comment">// indexed by the partition number, while the inner per-partition array</span>
    <span class="comment">// contains the replica broker ids. The first broker in each</span>
    <span class="comment">// broker id list will be the preferred replica.</span>
<span id="TopicSpecification.ReplicaAssignment"></span>    ReplicaAssignment [][]<a href="//golang.org/pkg/builtin/#int32">int32</a>
    <span class="comment">// Topic configuration.</span>
<span id="TopicSpecification.Config"></span>    Config map[<a href="//golang.org/pkg/builtin/#string">string</a>]<a href="//golang.org/pkg/builtin/#string">string</a>
}
</pre>
    <div id="footer">
     Build version go1.11.4.
     <br/>
     Except as
     <a href="https://developers.google.com/site-policies#restrictions">
      noted
     </a>
     ,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a
     <a href="//golang.org/LICENSE">
      BSD license
     </a>
     .
     <br/>
     <a href="//golang.org/doc/tos.html">
      Terms of Service
     </a>
     |
     <a href="http://www.google.com/intl/en/policies/privacy/">
      Privacy Policy
     </a>
    </div>
   </div>
   <!-- .container -->
  </div>
  <!-- #page -->
 </body>
</html>

